// Console stdlib tests using zena:test
import {suite, test, TestContext} from 'zena:test';
import {equal} from 'zena:assert';
import {console} from 'zena:console';

// TODO: Once zena:process provides stdout/stderr streams, we could:
// 1. Redirect stdout/stderr to a StringBuffer before each test
// 2. Call console.log/error/warn/etc
// 3. Read the buffer to verify the actual output strings and log levels
// This would test message formatting and level routing without host integration.
// For now, these tests only verify that console methods execute without throwing.
// See packages/runtime/test/console_test.ts for host integration tests that
// capture and verify actual output values.

export let tests = suite('Console', (): void => {
  test('console.log() with string', (ctx: TestContext): void => {
    console.log('Hello, World!');
    // Note: We cannot capture console output in portable tests,
    // so we just verify the call doesn't throw
  });

  test('console.log() with string concatenation', (ctx: TestContext): void => {
    console.log('Hello, ' + 'World!');
  });

  test('console.error() with string', (ctx: TestContext): void => {
    console.error('An error occurred!');
  });

  test('console.warn() with string', (ctx: TestContext): void => {
    console.warn('Warning!');
  });

  test('console.info() with string', (ctx: TestContext): void => {
    console.info('Info message');
  });

  test('console.debug() with string', (ctx: TestContext): void => {
    console.debug('Debug info');
  });

  test('multiple console.log() calls', (ctx: TestContext): void => {
    console.log('First');
    console.log('Second');
    console.log('Third');
  });

  test('mixed console methods', (ctx: TestContext): void => {
    console.log('Log message');
    console.error('Error message');
    console.warn('Warn message');
  });
});
