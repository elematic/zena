/**
 * @file
 *
 * Linear Memory Management
 *
 * Provides low-level access to WASM linear memory for WASI interop and FFI.
 * See docs/design/linear-memory.md for the full design.
 */

import {div} from 'zena:math';

// =============================================================================
// Memory Class - Array-like access to linear memory
// =============================================================================

/**
 * Represents the WASM linear memory as an array-like object.
 * Provides typed access to memory via operator overloading.
 */
export final class Memory {
  /** The default memory instance (memory index 0). */
  static default: Memory = new Memory();

  #new() {}

  /** Get the current size of linear memory in 64KB pages. */
  @intrinsic('memory.size')
  declare size(): i32;

  /**
   * Grow linear memory by the specified number of pages.
   * Returns the previous size in pages, or -1 on failure.
   */
  @intrinsic('memory.grow')
  declare grow(pages: i32): i32;

  /** The current size in bytes. */
  byteLength: i32 {
    get {
      return this.size() << 16;
    }
  }

  // ---------------------------------------------------------------------------
  // Byte access (u8)
  // ---------------------------------------------------------------------------

  /** Load an unsigned byte from the given address. */
  @intrinsic('i32.load8_u')
  declare getU8(ptr: i32): i32;

  /** Store a byte at the given address. */
  @intrinsic('i32.store8')
  declare setU8(ptr: i32, value: i32): void;

  // ---------------------------------------------------------------------------
  // 32-bit integer access
  // ---------------------------------------------------------------------------

  /** Load a 32-bit signed integer from the given address. */
  @intrinsic('i32.load')
  declare getI32(ptr: i32): i32;

  /** Store a 32-bit integer at the given address. */
  @intrinsic('i32.store')
  declare setI32(ptr: i32, value: i32): void;

  // ---------------------------------------------------------------------------
  // 64-bit integer access
  // ---------------------------------------------------------------------------

  /** Load a 64-bit signed integer from the given address. */
  @intrinsic('i64.load')
  declare getI64(ptr: i32): i64;

  /** Store a 64-bit integer at the given address. */
  @intrinsic('i64.store')
  declare setI64(ptr: i32, value: i64): void;

  // ---------------------------------------------------------------------------
  // Floating point access
  // ---------------------------------------------------------------------------

  /** Load a 32-bit float from the given address. */
  @intrinsic('f32.load')
  declare getF32(ptr: i32): f32;

  /** Store a 32-bit float at the given address. */
  @intrinsic('f32.store')
  declare setF32(ptr: i32, value: f32): void;

  /** Load a 64-bit float from the given address. */
  @intrinsic('f64.load')
  declare getF64(ptr: i32): f64;

  /** Store a 64-bit float at the given address. */
  @intrinsic('f64.store')
  declare setF64(ptr: i32, value: f64): void;

  // ---------------------------------------------------------------------------
  // Array-like byte access via operator overloading
  // ---------------------------------------------------------------------------

  /** Read a byte at the given index. */
  @intrinsic('i32.load8_u')
  declare operator [](index: i32): i32;

  /** Write a byte at the given index. */
  @intrinsic('i32.store8')
  declare operator []=(index: i32, value: i32): void;
}

// =============================================================================
// Allocator Interface
// =============================================================================

/**
 * Interface for linear memory allocators.
 * Libraries should accept Allocator to allow flexible memory strategies.
 *
 * Allocation methods return `(true, ptr) | (false, never)` to force callers
 * to handle allocation failures. Use pattern matching:
 * ```zena
 * if (let (true, ptr) = alloc.alloc(size)) {
 *   // use ptr
 * } else {
 *   // handle out of memory
 * }
 * ```
 */
export interface Allocator {
  /** Allocate `bytes` bytes. Returns (true, ptr) on success, (false, _) on failure. */
  alloc(bytes: i32): (true, i32) | (false, never);
  
  /** Allocate `bytes` bytes aligned to `align` (must be power of 2). */
  allocAligned(bytes: i32, align: i32): (true, i32) | (false, never);
  
  /** Free a previously allocated pointer. May be a no-op for some allocators. */
  free(ptr: i32): void;
}

// =============================================================================
// FreeListAllocator - General-purpose allocator (default)
// =============================================================================

/**
 * A free-list allocator that supports both alloc() and free().
 * 
 * Uses a simple first-fit free list. Each block has an 8-byte header:
 *   [size: i32, next: i32]  (next is only used when block is free)
 * 
 * This is the recommended allocator for general use where memory needs
 * to be reclaimed.
 */
export final class FreeListAllocator implements Allocator {
  /** The default allocator, starting at byte 64 (after WASI reserved region). */
  static default: FreeListAllocator = new FreeListAllocator(64);

  #startPtr: i32;
  #nextPtr: i32;      // Next fresh allocation point (bump pointer for new space)
  #freeList: i32;     // Head of free list (0 = empty)

  #new(startPtr: i32) {
    this.#startPtr = startPtr;
    this.#nextPtr = startPtr;
    this.#freeList = 0;
  }

  /** Allocate `bytes` bytes of linear memory. */
  alloc(bytes: i32): (true, i32) | (false, never) {
    // Minimum allocation is 8 bytes (for free list pointers when freed)
    var size = bytes;
    if (size < 8) {
      size = 8;
    }
    // Align to 8 bytes
    size = (size + 7) & (7 ^ -1);
    
    let mem = Memory.default;
    
    // First, search free list for a suitable block
    var prevPtr: i32 = 0;
    var currPtr = this.#freeList;
    
    while (currPtr != 0) {
      let blockSize = mem.getI32(currPtr);
      let nextFree = mem.getI32(currPtr + 4);
      
      if (blockSize >= size) {
        // Found a suitable block - remove from free list
        if (prevPtr == 0) {
          this.#freeList = nextFree;
        } else {
          mem.setI32(prevPtr + 4, nextFree);
        }
        
        // If block is significantly larger, split it
        let remaining = blockSize - size - 8;
        if (remaining >= 16) {
          // Split: shrink this block, add remainder to free list
          mem.setI32(currPtr, size);
          let newBlock = currPtr + 8 + size;
          mem.setI32(newBlock, remaining);
          mem.setI32(newBlock + 4, this.#freeList);
          this.#freeList = newBlock;
        }
        
        // Return pointer after header
        return (true, currPtr + 8);
      }
      
      prevPtr = currPtr;
      currPtr = nextFree;
    }
    
    // No suitable free block - allocate fresh space
    let totalSize = size + 8;  // Include header
    let ptr = this.#nextPtr;
    this.#nextPtr = ptr + totalSize;
    
    // Grow memory if needed
    let currentBytes = mem.size() << 16;
    if (this.#nextPtr > currentBytes) {
      let needed = div(this.#nextPtr - currentBytes + 65535, 65536);
      let result = mem.grow(needed);
      if (result == -1) {
        this.#nextPtr = ptr;
        return (false, _);
      }
    }
    
    // Write header
    mem.setI32(ptr, size);
    
    // Return pointer after header
    return (true, ptr + 8);
  }

  /** Allocate with alignment. */
  allocAligned(bytes: i32, align: i32): (true, i32) | (false, never) {
    // For simplicity, allocate extra and align within
    // This wastes some space but keeps the implementation simple
    if (let (true, ptr) = this.alloc(bytes + align - 1)) {
      let mask = align - 1;
      let aligned = (ptr + mask) & (mask ^ -1);
      
      // Note: this wastes the unaligned prefix, but free() still works
      // because we track the original pointer in a more sophisticated impl.
      // For now, accept the waste.
      return (true, aligned);
    } else {
      return (false, _);
    }
  }

  /** Free a previously allocated pointer. */
  free(ptr: i32): void {
    if (ptr == 0) {
      return;
    }
    
    let mem = Memory.default;
    
    // Header is 8 bytes before the user pointer
    let headerPtr = ptr - 8;
    let size = mem.getI32(headerPtr);
    
    // Add to free list
    mem.setI32(headerPtr + 4, this.#freeList);
    this.#freeList = headerPtr;
  }

  /** Get approximate bytes currently allocated (not including freed). */
  allocated: i32 {
    get {
      return this.#nextPtr - this.#startPtr;
    }
  }
}

// =============================================================================
// BumpAllocator - Fast arena-style allocator
// =============================================================================

/**
 * A bump-pointer allocator for arena-style memory management.
 * 
 * Fast allocation (just increment a pointer), but free() is a no-op.
 * Use reset() to free all allocations at once.
 * 
 * To create a BumpAllocator, first allocate a region from the root allocator:
 * ```zena
 * if (let (true, region) = defaultAllocator.alloc(4096)) {
 *   let arena = new BumpAllocator(region, 4096);
 *   if (let (true, ptr) = arena.alloc(64)) {
 *     // use ptr
 *   }
 *   arena.reset();  // Reuse the arena
 *   defaultAllocator.free(region);
 * }
 * ```
 * 
 * Best for: temporary allocations with known lifetime, scratch buffers.
 */
export final class BumpAllocator implements Allocator {
  #startPtr: i32;
  #endPtr: i32;
  #nextPtr: i32;

  /**
   * Create a BumpAllocator over a pre-allocated memory region.
   * @param startPtr Start of the region (from another allocator)
   * @param size Size of the region in bytes
   */
  #new(startPtr: i32, size: i32) {
    this.#startPtr = startPtr;
    this.#endPtr = startPtr + size;
    this.#nextPtr = startPtr;
  }

  /** Allocate `bytes` bytes. Returns (true, ptr) on success, (false, _) if exhausted. */
  alloc(bytes: i32): (true, i32) | (false, never) {
    let ptr = this.#nextPtr;
    let newNext = ptr + bytes;
    
    if (newNext > this.#endPtr) {
      // Arena exhausted - cannot grow (bounded region)
      return (false, _);
    }
    
    this.#nextPtr = newNext;
    return (true, ptr);
  }

  /** Allocate with alignment. Returns (true, ptr) on success, (false, _) if exhausted. */
  allocAligned(bytes: i32, align: i32): (true, i32) | (false, never) {
    let mask = align - 1;
    let notMask = mask ^ -1;
    let aligned = (this.#nextPtr + mask) & notMask;
    
    let newNext = aligned + bytes;
    if (newNext > this.#endPtr) {
      return (false, _);
    }
    
    this.#nextPtr = newNext;
    return (true, aligned);
  }

  /** Free is a no-op for bump allocators. Use reset() instead. */
  free(ptr: i32): void {
    // No-op: bump allocators don't support individual frees
  }

  /**
   * Reset the allocator to its initial state, allowing reuse.
   * WARNING: This invalidates ALL previously allocated pointers!
   */
  reset(): void {
    this.#nextPtr = this.#startPtr;
  }

  /** The number of bytes currently allocated. */
  allocated: i32 {
    get {
      return this.#nextPtr - this.#startPtr;
    }
  }

  /** The number of bytes remaining in the arena. */
  remaining: i32 {
    get {
      return this.#endPtr - this.#nextPtr;
    }
  }
}

// =============================================================================
// Default Allocator
// =============================================================================

/** 
 * The default allocator for general use. Supports alloc() and free().
 * This is the FreeListAllocator.default instance.
 */
export let defaultAllocator: FreeListAllocator = FreeListAllocator.default;
