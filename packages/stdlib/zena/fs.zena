/**
 * Filesystem Standard Library - WASI Preview 1 Implementation
 * 
 * Provides file and directory operations using wasi_snapshot_preview1 interfaces.
 * See docs/design/filesystem.md for the full design.
 * 
 * ## WASI Capability-Based Security
 * 
 * WASI uses a capability-based security model for filesystem access. Unlike
 * traditional operating systems where processes can access any file path they
 * have permission to, WASI programs have NO filesystem access by default.
 * 
 * Access is granted through "preopened directories" - directories that the
 * host environment explicitly passes to the WASM module at startup. The module
 * can only access files within these preopened directories.
 * 
 * For example, when running with wasmtime:
 * ```
 * wasmtime run --dir /data::/data --dir /tmp::/tmp myprogram.wasm
 * ```
 * This grants access to `/data` and `/tmp` on the host, mapped to the same
 * paths in the guest. Without these flags, the program cannot access the
 * filesystem at all.
 * 
 * The high-level functions (`readFile`, `writeFile`, etc.) use the first
 * preopened directory as the root. For more control, use `getPreopens()` to
 * access all available directories, or work with `Descriptor` objects directly.
 */

import { newByteArray, copyBytes } from 'zena:byte-array';
import { String, Encoding } from 'zena:string';
import { Memory, Allocator, defaultAllocator } from 'zena:memory';
import { Error } from 'zena:error';
import { Array } from 'zena:growable-array';

// ============================================================================
// Error Types
// ============================================================================

// WASI Preview 1 error codes (errno values)
export enum FsErrorCode {
  Success,          // No error (0)
  Access,           // Permission denied (2)
  BadDescriptor,    // Bad file descriptor (8)
  Exist,            // File exists (20)
  NotFound,         // No such file or directory (44)
  IsDirectory,      // Is a directory (31)
  NotDirectory,     // Not a directory (54)
  NotEmpty,         // Directory not empty (55)
  ReadOnly,         // Read-only file system (69)
  InvalidSeek,      // Invalid seek (70)
  Io,               // I/O error (29)
  InvalidArgument,  // Invalid argument (28)
  TooManyLinks,     // Too many symbolic links (72)
  NameTooLong,      // Filename too long (37)
  NoSpace,          // No space left on device (51)
  NotPermitted,     // Operation not permitted (63)
}

// Convert WASI errno to FsErrorCode
let __errnoToCode = (errno: i32): FsErrorCode => {
  return match (errno) {
    case 0: FsErrorCode.Success
    case 2: FsErrorCode.Access
    case 8: FsErrorCode.BadDescriptor
    case 20: FsErrorCode.Exist
    case 44: FsErrorCode.NotFound
    case 31: FsErrorCode.IsDirectory
    case 54: FsErrorCode.NotDirectory
    case 55: FsErrorCode.NotEmpty
    case 69: FsErrorCode.ReadOnly
    case 70: FsErrorCode.InvalidSeek
    case 29: FsErrorCode.Io
    case 28: FsErrorCode.InvalidArgument
    case 72: FsErrorCode.TooManyLinks
    case 37: FsErrorCode.NameTooLong
    case 51: FsErrorCode.NoSpace
    case 63: FsErrorCode.NotPermitted
    case _: FsErrorCode.Io
  };
};

export class FsError extends Error {
  code: FsErrorCode;
  errno: i32;

  #new(errno: i32, message: string) {
    super(message);
    this.errno = errno;
    this.code = __errnoToCode(errno);
  }
}

// ============================================================================
// File Types
// ============================================================================

// Type of filesystem entry (matches WASI filetype)
export enum FileType {
  Unknown,        // 0
  BlockDevice,    // 1
  CharacterDevice,// 2
  Directory,      // 3
  RegularFile,    // 4
  SymbolicLink,   // 7
  Socket,         // 6 - note: out of order in WASI
}

// File metadata
export type FileStat = {
  fileType: FileType,
  size: i64,
};

// Directory entry
export type DirEntry = {
  name: string,
  fileType: FileType,
};

// Open flags for openAt
export enum OpenFlags {
  None,       // No special flags (0)
  Create,     // Create file if it doesn't exist (1)
  Directory,  // Fail if not a directory (2)
  Exclusive,  // Fail if file exists (with Create) (4)
  Truncate,   // Truncate file to zero length (8)
}

// Descriptor flags (permissions)
export enum DescriptorFlags {
  Read,           // Allow reads
  Write,          // Allow writes
  ReadWrite,      // Allow both
  MutateDirectory, // Allow directory modifications
}

// ============================================================================
// Low-Level WASI Preview 1 Bindings
// ============================================================================

// Memory access aliases for convenience
let mem = Memory.default;

// --- File descriptor management ---

// Close a file descriptor
@external("wasi_snapshot_preview1", "fd_close")
declare function __wasi_fd_close(fd: i32): i32;

// Read from a file descriptor
// iovs is an array of (buf_ptr, buf_len) pairs
@external("wasi_snapshot_preview1", "fd_read")
declare function __wasi_fd_read(
  fd: i32,
  iovs: i32,      // Pointer to iovec array
  iovsLen: i32,   // Number of iovecs
  nreadPtr: i32   // Pointer to store bytes read
): i32;

// Write to a file descriptor
@external("wasi_snapshot_preview1", "fd_write")
declare function __wasi_fd_write(
  fd: i32,
  iovs: i32,      // Pointer to iovec array
  iovsLen: i32,   // Number of iovecs
  nwrittenPtr: i32 // Pointer to store bytes written
): i32;

// Seek within a file
@external("wasi_snapshot_preview1", "fd_seek")
declare function __wasi_fd_seek(
  fd: i32,
  offset: i64,
  whence: i32,    // 0=SET, 1=CUR, 2=END
  newoffsetPtr: i32
): i32;

// Get file descriptor stat
@external("wasi_snapshot_preview1", "fd_filestat_get")
declare function __wasi_fd_filestat_get(
  fd: i32,
  statPtr: i32
): i32;

// Read directory entries
@external("wasi_snapshot_preview1", "fd_readdir")
declare function __wasi_fd_readdir(
  fd: i32,
  bufPtr: i32,
  bufLen: i32,
  cookie: i64,
  bufusedPtr: i32
): i32;

// --- Path operations ---

// Open a file relative to a directory fd
@external("wasi_snapshot_preview1", "path_open")
declare function __wasi_path_open(
  dirfd: i32,
  dirflags: i32,   // lookupflags (1 = follow symlinks)
  pathPtr: i32,
  pathLen: i32,
  oflags: i32,     // open flags (create, trunc, etc)
  fsRightsBase: i64,
  fsRightsInheriting: i64,
  fdflags: i32,
  fdPtr: i32       // Pointer to store new fd
): i32;

// Get file stat by path
@external("wasi_snapshot_preview1", "path_filestat_get")
declare function __wasi_path_filestat_get(
  fd: i32,
  flags: i32,
  pathPtr: i32,
  pathLen: i32,
  statPtr: i32
): i32;

// Create a directory
@external("wasi_snapshot_preview1", "path_create_directory")
declare function __wasi_path_create_directory(
  fd: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// Unlink a file
@external("wasi_snapshot_preview1", "path_unlink_file")
declare function __wasi_path_unlink_file(
  fd: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// Remove a directory
@external("wasi_snapshot_preview1", "path_remove_directory")
declare function __wasi_path_remove_directory(
  fd: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// --- Preopen discovery ---

// Get prestat info for an fd (to discover preopened dirs)
@external("wasi_snapshot_preview1", "fd_prestat_get")
declare function __wasi_fd_prestat_get(
  fd: i32,
  prestatPtr: i32
): i32;

// Get the preopened directory name
@external("wasi_snapshot_preview1", "fd_prestat_dir_name")
declare function __wasi_fd_prestat_dir_name(
  fd: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// ============================================================================
// WASI Rights Constants
// ============================================================================

// Common rights for files
let RIGHTS_FD_READ: i64 = 2 as i64;          // fd_read
let RIGHTS_FD_WRITE: i64 = 64 as i64;        // fd_write
let RIGHTS_FD_SEEK: i64 = 4 as i64;          // fd_seek
let RIGHTS_FD_FILESTAT_GET: i64 = 2097152 as i64;
let RIGHTS_FD_READDIR: i64 = 16384 as i64;
let RIGHTS_PATH_OPEN: i64 = 256 as i64;
let RIGHTS_PATH_CREATE_DIR: i64 = 512 as i64;
let RIGHTS_PATH_FILESTAT_GET: i64 = 262144 as i64;
let RIGHTS_PATH_UNLINK: i64 = 67108864 as i64;
let RIGHTS_PATH_REMOVE_DIR: i64 = 33554432 as i64;

// Combined rights for read operations
let RIGHTS_READ: i64 = RIGHTS_FD_READ | RIGHTS_FD_SEEK | RIGHTS_FD_FILESTAT_GET;

// Combined rights for write operations  
let RIGHTS_WRITE: i64 = RIGHTS_FD_WRITE | RIGHTS_FD_SEEK | RIGHTS_FD_FILESTAT_GET;

// Combined rights for directory operations
let RIGHTS_DIR: i64 = RIGHTS_FD_READDIR | RIGHTS_PATH_OPEN | RIGHTS_PATH_CREATE_DIR 
                    | RIGHTS_PATH_FILESTAT_GET | RIGHTS_PATH_UNLINK | RIGHTS_PATH_REMOVE_DIR;

// All rights (for inheriting)
let RIGHTS_ALL: i64 = (0x1ffffff as i64);

// ============================================================================
// Memory Allocation
// ============================================================================

// Use the shared allocator from zena:memory
let alloc: Allocator = defaultAllocator;

// Helper to allocate or panic - for critical allocations that cannot fail
let allocOrPanic = (size: i32): i32 => {
  if (let (true, ptr) = alloc.alloc(size)) {
    return ptr;
  }
  throw new Error("Out of memory");
};

let allocAlignedOrPanic = (size: i32, align: i32): i32 => {
  if (let (true, ptr) = alloc.allocAligned(size, align)) {
    return ptr;
  }
  throw new Error("Out of memory");
};

// Scratch buffer for small temporary operations (WASI return values, etc.)
// Allocated once at module initialization.
let SCRATCH_SIZE: i32 = 4096;
let SCRATCH_PTR: i32 = allocAlignedOrPanic(SCRATCH_SIZE, 8);

// ============================================================================
// String/Memory Conversion Utilities
// ============================================================================

// Copy a Zena string to linear memory, return (ptr, len)
let __stringToLinear = (s: string): [i32, i32] => {
  let len = s.length;
  let ptr = allocOrPanic(len);
  for (var i = 0; i < len; i = i + 1) {
    mem[ptr + i] = s.getByteAt(i);
  }
  return [ptr, len];
};

// Read a string from linear memory
let __linearToString = (ptr: i32, len: i32): string => {
  // Build a GC byte array from linear memory
  let bytes = newByteArray(len);
  for (var i = 0; i < len; i = i + 1) {
    __byte_array_set(bytes, i, mem[ptr + i]);
  }
  // Create string from the byte array
  return new String(bytes, 0, len, Encoding.WTF8);
};

// Convert errno to string for error messages
let __errnoToString = (errno: i32): string => {
  return match (errno) {
    case 2: "EACCES"
    case 8: "EBADF"
    case 20: "EEXIST"
    case 28: "EINVAL"
    case 29: "EIO"
    case 31: "EISDIR"
    case 37: "ENAMETOOLONG"
    case 44: "ENOENT"
    case 51: "ENOSPC"
    case 54: "ENOTDIR"
    case 55: "ENOTEMPTY"
    case 63: "EPERM"
    case 69: "EROFS"
    case 70: "ESPIPE"
    case 72: "ELOOP"
    case _: "UNKNOWN"
  };
};

// Check WASI errno and throw if non-zero
let __checkErrno = (errno: i32, operation: string): void => {
  if (errno != 0) {
    throw new FsError(errno, operation + " failed with errno " + __errnoToString(errno));
  }
};

// Convert WASI filetype to our FileType enum
let __wasiFiletypeToFileType = (ft: i32): FileType => {
  return match (ft) {
    case 0: FileType.Unknown
    case 1: FileType.BlockDevice
    case 2: FileType.CharacterDevice
    case 3: FileType.Directory
    case 4: FileType.RegularFile
    case 6: FileType.Socket
    case 7: FileType.SymbolicLink
    case _: FileType.Unknown
  };
};

// ============================================================================
// Descriptor Class
// ============================================================================

/**
 * A handle for an open file or directory.
 * 
 * Descriptors are obtained either from `getPreopens()` (for preopened
 * directories) or by opening files/directories relative to an existing
 * descriptor using `openAt()` or `createAt()`.
 * 
 * In WASI's capability model, a Descriptor acts as a capability token - you
 * can only access files that are reachable from a Descriptor you already have.
 * 
 * Always call `close()` when done to release the underlying resource.
 * 
 * @example
 * ```
 * let root = getRootDir();
 * let file = root.openAt('data.txt', DescriptorFlags.Read);
 * let content = file.readString();
 * file.close();
 * ```
 */
export class Descriptor {
  #fd: i32;
  #closed: boolean;

  #new(fd: i32) {
    this.#fd = fd;
    this.#closed = false;
  }

  // Get the underlying file descriptor (for advanced use)
  fd: i32 {
    get {
      return this.#fd;
    }
  }

  // Read the entire file contents as bytes
  readAllBytes(): ByteArray {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    // First, seek to beginning
    let seekErrno = __wasi_fd_seek(this.#fd, 0 as i64, 0, SCRATCH_PTR);
    __checkErrno(seekErrno, "seek");

    // Read in chunks
    let chunks = new Array<[i32, i32]>();  // [(bufPtr, len), ...]
    var totalLen = 0;
    let chunkSize = 4096;
    
    while (true) {
      // Allocate buffer for this chunk
      let bufPtr = allocOrPanic(chunkSize);
      
      // Set up iovec: [buf_ptr, buf_len]
      mem.setI32(SCRATCH_PTR, bufPtr);
      mem.setI32(SCRATCH_PTR + 4, chunkSize);
      
      // Read
      let errno = __wasi_fd_read(this.#fd, SCRATCH_PTR, 1, SCRATCH_PTR + 8);
      __checkErrno(errno, "read");
      
      let nread = mem.getI32(SCRATCH_PTR + 8);
      
      if (nread > 0) {
        chunks.push([bufPtr, nread]);
        totalLen = totalLen + nread;
      }
      
      if (nread < chunkSize) {
        break;  // EOF
      }
    }
    
    // Combine chunks into ByteArray
    let result = newByteArray(totalLen);
    var pos = 0;
    for (var c = 0; c < chunks.length; c = c + 1) {
      let [bufPtr, len] = chunks[c];
      for (var i = 0; i < len; i = i + 1) {
        __byte_array_set(result, pos, mem[bufPtr + i]);
        pos = pos + 1;
      }
    }
    
    return result;
  }

  // Read the entire file as a UTF-8 string
  readString(): string {
    let bytes = this.readAllBytes();
    return new String(bytes, 0, __byte_array_length(bytes), Encoding.WTF8);
  }

  // Write bytes to the file (truncates/overwrites)
  writeBytes(data: ByteArray): void {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let len = __byte_array_length(data);
    let ptr = allocOrPanic(len);
    
    // Copy data to linear memory
    for (var i = 0; i < len; i = i + 1) {
      mem[ptr + i] = __byte_array_get(data, i);
    }
    
    // Set up iovec
    mem.setI32(SCRATCH_PTR, ptr);
    mem.setI32(SCRATCH_PTR + 4, len);
    
    let errno = __wasi_fd_write(this.#fd, SCRATCH_PTR, 1, SCRATCH_PTR + 8);
    __checkErrno(errno, "write");
  }

  // Write a string (UTF-8) to the file
  writeString(data: string): void {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [ptr, len] = __stringToLinear(data);
    
    // Set up iovec
    mem.setI32(SCRATCH_PTR, ptr);
    mem.setI32(SCRATCH_PTR + 4, len);
    
    let errno = __wasi_fd_write(this.#fd, SCRATCH_PTR, 1, SCRATCH_PTR + 8);
    __checkErrno(errno, "write");
  }

  // Open a file or directory relative to this descriptor
  openAt(path: string, flags: DescriptorFlags): Descriptor {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    
    // Compute rights based on flags
    // DescriptorFlags: Read=0, Write=1, ReadWrite=2, MutateDirectory=3
    let rights = match (flags as i32) {
      case 0: RIGHTS_READ                    // Read
      case 1: RIGHTS_WRITE                   // Write
      case 2: RIGHTS_READ | RIGHTS_WRITE     // ReadWrite
      case 3: RIGHTS_DIR                     // MutateDirectory
      case _: RIGHTS_READ                    // Default to read
    };
    
    let errno = __wasi_path_open(
      this.#fd,
      1,          // lookupflags: follow symlinks
      pathPtr,
      pathLen,
      0,          // oflags: none
      rights,
      RIGHTS_ALL, // inheriting rights
      0,          // fdflags
      SCRATCH_PTR
    );
    
    __checkErrno(errno, "open '" + path + "'");
    
    let newFd = mem.getI32(SCRATCH_PTR);
    return new Descriptor(newFd);
  }

  // Create a new file for writing (truncate if exists)
  createAt(path: string): Descriptor {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    
    // oflags: create (1) | truncate (8) = 9
    let errno = __wasi_path_open(
      this.#fd,
      1,            // lookupflags: follow symlinks
      pathPtr,
      pathLen,
      9,            // oflags: create | truncate
      RIGHTS_WRITE,
      RIGHTS_ALL,
      0,            // fdflags
      SCRATCH_PTR
    );
    
    __checkErrno(errno, "create '" + path + "'");
    
    let newFd = mem.getI32(SCRATCH_PTR);
    return new Descriptor(newFd);
  }

  // Get file metadata
  stat(): FileStat {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let errno = __wasi_fd_filestat_get(this.#fd, SCRATCH_PTR);
    __checkErrno(errno, "stat");
    
    // filestat layout (64 bytes):
    // 0: dev (u64)
    // 8: ino (u64)
    // 16: filetype (u8)
    // 24: nlink (u64)
    // 32: size (u64)
    // 40: atim (u64)
    // 48: mtim (u64)
    // 56: ctim (u64)
    let fileTypeRaw = mem[SCRATCH_PTR + 16];
    let size = mem.getI64(SCRATCH_PTR + 32);
    
    return { 
      fileType: __wasiFiletypeToFileType(fileTypeRaw), 
      size: size 
    };
  }

  // Get metadata for a path relative to this descriptor
  statAt(path: string): FileStat {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    
    let errno = __wasi_path_filestat_get(
      this.#fd,
      1,        // flags: follow symlinks
      pathPtr,
      pathLen,
      SCRATCH_PTR
    );
    
    __checkErrno(errno, "stat '" + path + "'");
    
    let fileTypeRaw = mem[SCRATCH_PTR + 16];
    let size = mem.getI64(SCRATCH_PTR + 32);
    
    return { 
      fileType: __wasiFiletypeToFileType(fileTypeRaw), 
      size: size 
    };
  }

  // List directory contents
  readDir(): Array<DirEntry> {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let entries = new Array<DirEntry>();
    var cookie: i64 = 0 as i64;
    let bufSize = 4096;
    let bufPtr = allocOrPanic(bufSize);
    
    while (true) {
      let errno = __wasi_fd_readdir(this.#fd, bufPtr, bufSize, cookie, SCRATCH_PTR);
      __checkErrno(errno, "readdir");
      
      let bufused = mem.getI32(SCRATCH_PTR);
      if (bufused == 0) {
        break;  // No more entries
      }
      
      // Parse directory entries
      // Each dirent is: d_next(u64) + d_ino(u64) + d_namlen(u32) + d_type(u8) + name
      var offset = 0;
      while (offset < bufused) {
        let dNext = mem.getI64(bufPtr + offset);
        // let dIno = mem.getI64(bufPtr + offset + 8);
        let dNamelen = mem.getI32(bufPtr + offset + 16);
        let dType = mem[bufPtr + offset + 20];
        
        // Entry header is 24 bytes, name follows
        let namePtr = bufPtr + offset + 24;
        
        // Check if name fits in buffer
        if (offset + 24 + dNamelen > bufused) {
          break;  // Partial entry, need to re-read
        }
        
        let name = __linearToString(namePtr, dNamelen);
        entries.push({ 
          name: name, 
          fileType: __wasiFiletypeToFileType(dType) 
        });
        
        cookie = dNext;
        offset = offset + 24 + dNamelen;
      }
      
      // If buffer was full, there may be more entries
      if (bufused < bufSize) {
        break;
      }
    }
    
    return entries;
  }

  // Create a directory
  mkdirAt(path: string): void {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    let errno = __wasi_path_create_directory(this.#fd, pathPtr, pathLen);
    __checkErrno(errno, "mkdir '" + path + "'");
  }

  // Delete a file
  unlinkAt(path: string): void {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    let errno = __wasi_path_unlink_file(this.#fd, pathPtr, pathLen);
    __checkErrno(errno, "unlink '" + path + "'");
  }

  // Delete a directory
  rmdirAt(path: string): void {
    if (this.#closed) {
      throw new FsError(8, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    let errno = __wasi_path_remove_directory(this.#fd, pathPtr, pathLen);
    __checkErrno(errno, "rmdir '" + path + "'");
  }

  // Close the descriptor
  close(): void {
    if (!this.#closed) {
      __wasi_fd_close(this.#fd);
      this.#closed = true;
    }
  }
}

// ============================================================================
// Preopened Directories
// ============================================================================

// Cache of preopened directories
var __preopensCache: Array<[Descriptor, string]> | null = null;

/**
 * Returns all preopened directories granted to this WASM module.
 * 
 * Preopened directories are the ONLY filesystem locations this program can
 * access. They are granted by the host environment at startup (e.g., via
 * wasmtime's `--dir` flag).
 * 
 * Each entry is a tuple of `[Descriptor, path]` where:
 * - `Descriptor` is a handle for filesystem operations within that directory
 * - `path` is the guest path (e.g., "/tmp", "/data", or "." for current dir)
 * 
 * Returns an empty array if no directories were preopened (the program has
 * no filesystem access).
 * 
 * @example
 * ```
 * let preopens = getPreopens();
 * for (let [dir, path] in preopens) {
 *   console.log('Access granted to: ' + path);
 * }
 * ```
 */
export let getPreopens = (): Array<[Descriptor, string]> => {
  let cached = __preopensCache;
  if (cached != null) {
    return cached;
  }
  
  let result = new Array<[Descriptor, string]>();
  
  // In WASI P1, preopened directories start at fd 3 (0=stdin, 1=stdout, 2=stderr)
  // We iterate upward until fd_prestat_get fails
  var fd = 3;
  while (true) {
    // prestat structure: tag (u8) + pr_name_len (u32 at offset 4)
    let errno = __wasi_fd_prestat_get(fd, SCRATCH_PTR);
    if (errno != 0) {
      break;  // No more preopened directories
    }
    
    // Check tag - 0 means directory
    let tag = mem[SCRATCH_PTR];
    if (tag != 0) {
      fd = fd + 1;
      continue;
    }
    
    let nameLen = mem.getI32(SCRATCH_PTR + 4);
    let namePtr = allocOrPanic(nameLen);
    
    let nameErrno = __wasi_fd_prestat_dir_name(fd, namePtr, nameLen);
    if (nameErrno != 0) {
      fd = fd + 1;
      continue;
    }
    
    let path = __linearToString(namePtr, nameLen);
    result.push([new Descriptor(fd), path]);
    
    fd = fd + 1;
  }
  
  __preopensCache = result;
  return result;
};

/**
 * Returns the first preopened directory, used as the "root" for high-level
 * file operations.
 * 
 * This is typically the current working directory (".") or the first `--dir`
 * flag passed to the WASI runtime.
 * 
 * @throws FsError if no directories were preopened.
 */
export let getRootDir = (): Descriptor => {
  let preopens = getPreopens();
  if (preopens.length == 0) {
    throw new FsError(44, "No preopened directories available");
  }
  return preopens[0][0];
};

// ============================================================================
// High-Level Convenience Functions
// ============================================================================
//
// These functions operate relative to the first preopened directory (see
// `getRootDir()`). For access to other preopened directories, use
// `getPreopens()` and work with `Descriptor` objects directly.

/**
 * Reads the entire contents of a file as a UTF-8 string.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file doesn't exist or cannot be read.
 */
export let readFile = (path: string): string => {
  let root = getRootDir();
  let file = root.openAt(path, DescriptorFlags.Read);
  let content = file.readString();
  file.close();
  return content;
};

/**
 * Reads the entire contents of a file as raw bytes.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file doesn't exist or cannot be read.
 */
export let readFileBytes = (path: string): ByteArray => {
  let root = getRootDir();
  let file = root.openAt(path, DescriptorFlags.Read);
  let content = file.readAllBytes();
  file.close();
  return content;
};

/**
 * Writes a string to a file as UTF-8, creating or truncating the file.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file cannot be written (e.g., permission denied,
 *         directory doesn't exist, or read-only filesystem).
 */
export let writeFile = (path: string, content: string): void => {
  let root = getRootDir();
  let file = root.createAt(path);
  file.writeString(content);
  file.close();
};

/**
 * Writes raw bytes to a file, creating or truncating the file.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file cannot be written.
 */
export let writeFileBytes = (path: string, content: ByteArray): void => {
  let root = getRootDir();
  let file = root.createAt(path);
  file.writeBytes(content);
  file.close();
};

/**
 * Lists the contents of a directory.
 * 
 * The path is relative to the first preopened directory.
 * Use "." to list the root preopened directory itself.
 * 
 * @returns Array of directory entries with name and file type.
 * @throws FsError if the path doesn't exist or is not a directory.
 */
export let listDir = (path: string): Array<DirEntry> => {
  let root = getRootDir();
  // For directory listing, we need to open with directory rights
  let [pathPtr, pathLen] = __stringToLinear(path);
  
  let errno = __wasi_path_open(
    root.fd,
    1,          // lookupflags: follow symlinks
    pathPtr,
    pathLen,
    2,          // oflags: directory
    RIGHTS_DIR | RIGHTS_FD_READDIR,
    RIGHTS_ALL,
    0,
    SCRATCH_PTR
  );
  __checkErrno(errno, "opendir '" + path + "'");
  
  let dirFd = mem.getI32(SCRATCH_PTR);
  let dir = new Descriptor(dirFd);
  let entries = dir.readDir();
  dir.close();
  return entries;
};

/**
 * Checks if a path exists (file or directory).
 * 
 * The path is relative to the first preopened directory.
 * 
 * @returns true if the path exists, false otherwise.
 */
export let exists = (path: string): boolean => {
  let root = getRootDir();
  return try {
    root.statAt(path);
    true
  } catch (e) {
    // Assume any error means doesn't exist (simplification)
    false
  };
};

/**
 * Checks if a path is a regular file.
 * 
 * @returns true if the path exists and is a file, false otherwise.
 */
export let isFile = (path: string): boolean => {
  let root = getRootDir();
  return try {
    let stat = root.statAt(path);
    stat.fileType == FileType.RegularFile
  } catch (e) {
    false
  };
};

/**
 * Checks if a path is a directory.
 * 
 * @returns true if the path exists and is a directory, false otherwise.
 */
export let isDirectory = (path: string): boolean => {
  let root = getRootDir();
  return try {
    let stat = root.statAt(path);
    stat.fileType == FileType.Directory
  } catch (e) {
    false
  };
};

/**
 * Creates a directory.
 * 
 * The path is relative to the first preopened directory.
 * Parent directories must already exist.
 * 
 * @throws FsError if the directory cannot be created.
 */
export let mkdir = (path: string): void => {
  let root = getRootDir();
  root.mkdirAt(path);
};

/**
 * Deletes a file.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file doesn't exist or cannot be deleted.
 */
export let unlink = (path: string): void => {
  let root = getRootDir();
  root.unlinkAt(path);
};

/**
 * Deletes an empty directory.
 * 
 * The path is relative to the first preopened directory.
 * The directory must be empty.
 * 
 * @throws FsError if the directory doesn't exist, is not empty, or cannot
 *         be deleted.
 */
export let rmdir = (path: string): void => {
  let root = getRootDir();
  root.rmdirAt(path);
};
