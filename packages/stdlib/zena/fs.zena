/**
 * Filesystem Standard Library - WASI 0.2 Implementation
 * 
 * Provides file and directory operations using wasi:filesystem interfaces.
 * See docs/design/filesystem.md for the full design.
 * 
 * ## WASI Capability-Based Security
 * 
 * WASI uses a capability-based security model for filesystem access. Unlike
 * traditional operating systems where processes can access any file path they
 * have permission to, WASI programs have NO filesystem access by default.
 * 
 * Access is granted through "preopened directories" - directories that the
 * host environment explicitly passes to the WASM module at startup. The module
 * can only access files within these preopened directories.
 * 
 * For example, when running with wasmtime:
 * ```
 * wasmtime run --dir /data::/data --dir /tmp::/tmp myprogram.wasm
 * ```
 * This grants access to `/data` and `/tmp` on the host, mapped to the same
 * paths in the guest. Without these flags, the program cannot access the
 * filesystem at all.
 * 
 * The high-level functions (`readFile`, `writeFile`, etc.) use the first
 * preopened directory as the root. For more control, use `getPreopens()` to
 * access all available directories, or work with `Descriptor` objects directly.
 */

import { newByteArray, copyBytes } from 'zena:byte-array';
import { String, Encoding } from 'zena:string';
import { Memory, Allocator, defaultAllocator } from 'zena:memory';
import { Error } from 'zena:error';
import { Array } from 'zena:growable-array';

// ============================================================================
// Error Types
// ============================================================================

// WASI filesystem error codes (subset of wasi:filesystem/types.error-code)
export enum FsErrorCode {
  Access,           // Permission denied
  BadDescriptor,    // Invalid file descriptor
  Exist,            // File already exists
  NotFound,         // No such file or directory
  IsDirectory,      // Is a directory (expected file)
  NotDirectory,     // Not a directory (expected directory)
  NotEmpty,         // Directory not empty
  ReadOnly,         // Read-only filesystem
  InvalidSeek,      // Invalid seek position
  Io,               // I/O error
  InvalidArgument,  // Invalid argument
  TooManyLinks,     // Too many symbolic links
  NameTooLong,      // Filename too long
  NoSpace,          // No space left on device
  NotPermitted,     // Operation not permitted
}

export class FsError extends Error {
  code: FsErrorCode;

  #new(code: FsErrorCode, message: string) {
    super(message);
    this.code = code;
  }
}

// ============================================================================
// File Types
// ============================================================================

// Type of filesystem entry
export enum FileType {
  Unknown,
  Directory,
  RegularFile,
  SymbolicLink,
  BlockDevice,
  CharacterDevice,
  Fifo,
  Socket,
}

// File metadata
export type FileStat = {
  fileType: FileType,
  size: i64,
};

// Directory entry
export type DirEntry = {
  name: string,
  fileType: FileType,
};

// Open flags for openAt
export enum OpenFlags {
  None,       // No special flags
  Create,     // Create file if it doesn't exist
  Directory,  // Fail if not a directory
  Exclusive,  // Fail if file exists (with Create)
  Truncate,   // Truncate file to zero length
}

// Descriptor flags (permissions)
export enum DescriptorFlags {
  Read,           // Allow reads
  Write,          // Allow writes
  ReadWrite,      // Allow both
  MutateDirectory, // Allow directory modifications
}

// ============================================================================
// Low-Level WASI Bindings
// ============================================================================

// Memory access aliases for convenience
let mem = Memory.default;

// --- wasi:filesystem/preopens ---

// get-directories returns a list of (descriptor, path) tuples
// For simplicity, we expose a lower-level interface that returns count and
// allows iteration
@external("wasi:filesystem/preopens", "get-directories")
declare function __wasi_preopens_get_directories(
  retPtr: i32  // Pointer to store [listPtr, listLen]
): void;

// --- wasi:filesystem/types - Descriptor methods ---

// Open a file/directory relative to this descriptor
// Returns descriptor handle on success, or error code (negative)
@external("wasi:filesystem/types", "[method]descriptor.open-at")
declare function __wasi_descriptor_open_at(
  handle: i32,      // Base descriptor handle
  pathFlags: i32,   // Path flags (follow symlinks, etc.)
  pathPtr: i32,     // Path string pointer
  pathLen: i32,     // Path string length
  openFlags: i32,   // Open flags (create, truncate, etc.)
  descFlags: i32    // Descriptor flags (read, write, etc.)
): i32;

// Read bytes from a file at a given offset
// Writes result to retPtr: [dataPtr, dataLen, eof: i32, errorCode: i32]
@external("wasi:filesystem/types", "[method]descriptor.read")
declare function __wasi_descriptor_read(
  handle: i32,
  length: i64,      // Max bytes to read
  offset: i64,      // File offset
  retPtr: i32       // Return value pointer
): void;

// Write bytes to a file at a given offset
// Returns bytes written on success, or error code (negative)
@external("wasi:filesystem/types", "[method]descriptor.write")
declare function __wasi_descriptor_write(
  handle: i32,
  bufferPtr: i32,   // Data pointer
  bufferLen: i32,   // Data length
  offset: i64       // File offset
): i64;

// Get file statistics
// Writes result to retPtr
@external("wasi:filesystem/types", "[method]descriptor.stat")
declare function __wasi_descriptor_stat(
  handle: i32,
  retPtr: i32       // Return value pointer
): void;

// Get statistics of a path relative to this descriptor
@external("wasi:filesystem/types", "[method]descriptor.stat-at")
declare function __wasi_descriptor_stat_at(
  handle: i32,
  pathFlags: i32,
  pathPtr: i32,
  pathLen: i32,
  retPtr: i32
): void;

// Start reading directory entries
// Returns stream handle on success, or error code (negative)
@external("wasi:filesystem/types", "[method]descriptor.read-directory")
declare function __wasi_descriptor_read_directory(handle: i32): i32;

// Create a directory
@external("wasi:filesystem/types", "[method]descriptor.create-directory-at")
declare function __wasi_descriptor_create_directory_at(
  handle: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// Remove a file
@external("wasi:filesystem/types", "[method]descriptor.unlink-file-at")
declare function __wasi_descriptor_unlink_file_at(
  handle: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// Remove a directory
@external("wasi:filesystem/types", "[method]descriptor.remove-directory-at")
declare function __wasi_descriptor_remove_directory_at(
  handle: i32,
  pathPtr: i32,
  pathLen: i32
): i32;

// --- wasi:filesystem/types - Directory entry stream methods ---

// Read next directory entry
// Writes result to retPtr
@external("wasi:filesystem/types", "[method]directory-entry-stream.read-directory-entry")
declare function __wasi_directory_entry_stream_read(
  handle: i32,
  retPtr: i32
): void;

// --- Resource lifecycle ---

// Drop a descriptor resource
@external("wasi:filesystem/types", "[resource-drop]descriptor")
declare function __wasi_descriptor_drop(handle: i32): void;

// Drop a directory-entry-stream resource
@external("wasi:filesystem/types", "[resource-drop]directory-entry-stream")
declare function __wasi_directory_entry_stream_drop(handle: i32): void;

// ============================================================================
// Memory Allocation
// ============================================================================

// Use the shared allocator from zena:memory
let alloc: Allocator = defaultAllocator;

// Helper to allocate or panic - for critical allocations that cannot fail
let allocOrPanic = (size: i32): i32 => {
  if (let (true, ptr) = alloc.alloc(size)) {
    return ptr;
  }
  // TODO: Use a proper panic mechanism once available
  throw new Error("Out of memory");
};

let allocAlignedOrPanic = (size: i32, align: i32): i32 => {
  if (let (true, ptr) = alloc.allocAligned(size, align)) {
    return ptr;
  }
  throw new Error("Out of memory");
};

// Scratch buffer for small temporary operations (WASI return values, etc.)
// Allocated once at module initialization.
let SCRATCH_SIZE: i32 = 1024;
let SCRATCH_PTR: i32 = allocAlignedOrPanic(SCRATCH_SIZE, 8);

// ============================================================================
// String/Memory Conversion Utilities
// ============================================================================

// Copy a Zena string to linear memory, return (ptr, len)
let __stringToLinear = (s: string): [i32, i32] => {
  let len = s.length;
  let ptr = allocOrPanic(len);
  for (var i = 0; i < len; i = i + 1) {
    mem[ptr + i] = s.getByteAt(i);
  }
  return [ptr, len];
};

// Read a string from linear memory
let __linearToString = (ptr: i32, len: i32): string => {
  // Build a GC byte array from linear memory
  let bytes = newByteArray(len);
  for (var i = 0; i < len; i = i + 1) {
    __byte_array_set(bytes, i, mem[ptr + i]);
  }
  // Create string from the byte array
  return new String(bytes, 0, len, Encoding.WTF8);
};

// Convert error code from WASI to FsError
let __checkError = (code: i32, operation: string): void => {
  if (code >= 0) {
    return;
  }
  
  let errCode = match (-code) {
    case 1: FsErrorCode.Access
    case 6: FsErrorCode.BadDescriptor
    case 12: FsErrorCode.Exist
    case 28: FsErrorCode.NotFound
    case 21: FsErrorCode.IsDirectory
    case 29: FsErrorCode.NotDirectory
    case 30: FsErrorCode.NotEmpty
    case 44: FsErrorCode.ReadOnly
    case _: FsErrorCode.Io
  };
  
  throw new FsError(errCode, operation + " failed");
};

// ============================================================================
// Descriptor Class
// ============================================================================

/**
 * A handle for an open file or directory.
 * 
 * Descriptors are obtained either from `getPreopens()` (for preopened
 * directories) or by opening files/directories relative to an existing
 * descriptor using `openAt()` or `createAt()`.
 * 
 * In WASI's capability model, a Descriptor acts as a capability token - you
 * can only access files that are reachable from a Descriptor you already have.
 * 
 * Always call `close()` when done to release the underlying resource.
 * 
 * @example
 * ```
 * let root = getRootDir();
 * let file = root.openAt('data.txt', DescriptorFlags.Read);
 * let content = file.readString();
 * file.close();
 * ```
 */
export class Descriptor {
  #handle: i32;
  #closed: boolean;

  #new(handle: i32) {
    this.#handle = handle;
    this.#closed = false;
  }

  // Read the entire file contents as bytes
  readAllBytes(): ByteArray {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    // First pass: read into temporary Array to determine size
    let chunks = new Array<[i32, i32]>();  // [(bufPtr, len), ...]
    var totalLen = 0;
    var offset: i64 = 0 as i64;
    let chunkSize: i64 = 4096 as i64;
    
    while (true) {
      // Allocate buffer for this chunk
      let bufPtr = allocOrPanic(4096);
      
      // Read chunk - result written to scratch area
      // Format: [dataLen: i32, eof: i32, errorCode: i32]
      __wasi_descriptor_read(this.#handle, chunkSize, offset, SCRATCH_PTR);
      
      let dataLen = mem.getI32(SCRATCH_PTR);
      let eof = mem.getI32(SCRATCH_PTR + 4);
      let errorCode = mem.getI32(SCRATCH_PTR + 8);
      
      __checkError(errorCode, "read");
      
      if (dataLen > 0) {
        chunks.push([bufPtr, dataLen]);
        totalLen = totalLen + dataLen;
      }
      
      if (eof != 0) {
        break;
      }
      
      offset = offset + (dataLen as i64);
    }
    
    // Second pass: copy to ByteArray
    let result = newByteArray(totalLen);
    var pos = 0;
    for (var c = 0; c < chunks.length; c = c + 1) {
      let [bufPtr, len] = chunks[c];
      for (var i = 0; i < len; i = i + 1) {
        __byte_array_set(result, pos, mem[bufPtr + i]);
        pos = pos + 1;
      }
    }
    
    return result;
  }

  // Read the entire file as a UTF-8 string
  readString(): string {
    let bytes = this.readAllBytes();
    return new String(bytes, 0, __byte_array_length(bytes), Encoding.WTF8);
  }

  // Write bytes to the file
  writeBytes(data: ByteArray): void {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let len = __byte_array_length(data);
    let ptr = allocOrPanic(len);
    
    // Copy data to linear memory
    for (var i = 0; i < len; i = i + 1) {
      mem[ptr + i] = __byte_array_get(data, i);
    }
    
    let written = __wasi_descriptor_write(this.#handle, ptr, len, 0 as i64);
    
    if (written < 0) {
      __checkError(written as i32, "write");
    }
  }

  // Write a string (UTF-8) to the file
  writeString(data: string): void {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [ptr, len] = __stringToLinear(data);
    let written = __wasi_descriptor_write(this.#handle, ptr, len, 0 as i64);
    
    if (written < 0) {
      __checkError(written as i32, "write");
    }
  }

  // Open a file or directory relative to this descriptor
  openAt(path: string, flags: DescriptorFlags): Descriptor {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    
    // Map DescriptorFlags to WASI flags
    // Read=0->1, Write=1->2, ReadWrite=2->3, MutateDirectory=3->4
    let descFlags = (flags as i32) + 1;
    
    let result = __wasi_descriptor_open_at(
      this.#handle,
      1,        // pathFlags: follow symlinks
      pathPtr,
      pathLen,
      0,        // openFlags: none
      descFlags
    );
    
    __checkError(result, "open");
    
    return new Descriptor(result);
  }

  // Create a new file for writing (truncate if exists)
  createAt(path: string): Descriptor {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    
    let result = __wasi_descriptor_open_at(
      this.#handle,
      1,        // pathFlags: follow symlinks
      pathPtr,
      pathLen,
      5,        // openFlags: create | truncate
      2         // descFlags: write
    );
    
    __checkError(result, "create");
    
    return new Descriptor(result);
  }

  // Get file metadata
  stat(): FileStat {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    __wasi_descriptor_stat(this.#handle, SCRATCH_PTR);
    
    let errorCode = mem.getI32(SCRATCH_PTR);
    __checkError(errorCode, "stat");
    
    // Parse stat result from scratch buffer
    // Format depends on WASI encoding - simplified here
    let fileTypeRaw = mem.getI32(SCRATCH_PTR + 4);
    let size = mem.getI64(SCRATCH_PTR + 8);
    
    let fileType = match (fileTypeRaw) {
      case 3: FileType.Directory
      case 4: FileType.RegularFile
      case 5: FileType.SymbolicLink
      case _: FileType.Unknown
    };
    
    return { fileType: fileType, size: size };
  }

  // Get metadata for a path relative to this descriptor
  statAt(path: string): FileStat {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    
    __wasi_descriptor_stat_at(
      this.#handle,
      1,        // pathFlags: follow symlinks
      pathPtr,
      pathLen,
      SCRATCH_PTR
    );
    
    let errorCode = mem.getI32(SCRATCH_PTR);
    __checkError(errorCode, "stat-at");
    
    let fileTypeRaw = mem.getI32(SCRATCH_PTR + 4);
    let size = mem.getI64(SCRATCH_PTR + 8);
    
    let fileType = match (fileTypeRaw) {
      case 3: FileType.Directory
      case 4: FileType.RegularFile
      case 5: FileType.SymbolicLink
      case _: FileType.Unknown
    };
    
    return { fileType: fileType, size: size };
  }

  // List directory contents
  readDir(): Array<DirEntry> {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let streamHandle = __wasi_descriptor_read_directory(this.#handle);
    __checkError(streamHandle, "read-directory");
    
    let entries = new Array<DirEntry>();
    
    while (true) {
      __wasi_directory_entry_stream_read(streamHandle, SCRATCH_PTR);
      
      let hasEntry = mem.getI32(SCRATCH_PTR);
      if (hasEntry == 0) {
        break;  // No more entries
      }
      
      let errorCode = mem.getI32(SCRATCH_PTR + 4);
      __checkError(errorCode, "read-directory-entry");
      
      // Parse entry from scratch buffer
      let fileTypeRaw = mem.getI32(SCRATCH_PTR + 8);
      let namePtr = mem.getI32(SCRATCH_PTR + 12);
      let nameLen = mem.getI32(SCRATCH_PTR + 16);
      
      let name = __linearToString(namePtr, nameLen);
      let fileType = match (fileTypeRaw) {
        case 3: FileType.Directory
        case 4: FileType.RegularFile
        case 5: FileType.SymbolicLink
        case _: FileType.Unknown
      };
      
      entries.push({ name: name, fileType: fileType });
    }
    
    __wasi_directory_entry_stream_drop(streamHandle);
    
    return entries;
  }

  // Create a directory
  mkdirAt(path: string): void {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    let result = __wasi_descriptor_create_directory_at(this.#handle, pathPtr, pathLen);
    __checkError(result, "mkdir");
  }

  // Delete a file
  unlinkAt(path: string): void {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    let result = __wasi_descriptor_unlink_file_at(this.#handle, pathPtr, pathLen);
    __checkError(result, "unlink");
  }

  // Delete a directory
  rmdirAt(path: string): void {
    if (this.#closed) {
      throw new FsError(FsErrorCode.BadDescriptor, "Descriptor is closed");
    }

    let [pathPtr, pathLen] = __stringToLinear(path);
    let result = __wasi_descriptor_remove_directory_at(this.#handle, pathPtr, pathLen);
    __checkError(result, "rmdir");
  }

  // Close the descriptor
  close(): void {
    if (!this.#closed) {
      __wasi_descriptor_drop(this.#handle);
      this.#closed = true;
    }
  }
}

// ============================================================================
// Preopened Directories
// ============================================================================

// Cache of preopened directories
var __preopensCache: Array<[Descriptor, string]> | null = null;

/**
 * Returns all preopened directories granted to this WASM module.
 * 
 * Preopened directories are the ONLY filesystem locations this program can
 * access. They are granted by the host environment at startup (e.g., via
 * wasmtime's `--dir` flag).
 * 
 * Each entry is a tuple of `[Descriptor, path]` where:
 * - `Descriptor` is a handle for filesystem operations within that directory
 * - `path` is the guest path (e.g., "/tmp", "/data", or "." for current dir)
 * 
 * Returns an empty array if no directories were preopened (the program has
 * no filesystem access).
 * 
 * @example
 * ```
 * let preopens = getPreopens();
 * for (let [dir, path] in preopens) {
 *   console.log('Access granted to: ' + path);
 * }
 * ```
 */
export let getPreopens = (): Array<[Descriptor, string]> => {
  let cached = __preopensCache;
  if (cached != null) {
    return cached;
  }
  
  // Call WASI to get preopens list
  __wasi_preopens_get_directories(SCRATCH_PTR);
  
  let listPtr = mem.getI32(SCRATCH_PTR);
  let listLen = mem.getI32(SCRATCH_PTR + 4);
  
  let result = new Array<[Descriptor, string]>();
  
  for (var i = 0; i < listLen; i = i + 1) {
    // Each entry is (handle: i32, pathPtr: i32, pathLen: i32)
    let entryPtr = listPtr + (i * 12);
    let handle = mem.getI32(entryPtr);
    let pathPtr = mem.getI32(entryPtr + 4);
    let pathLen = mem.getI32(entryPtr + 8);
    
    let path = __linearToString(pathPtr, pathLen);
    result.push([new Descriptor(handle), path]);
  }
  
  __preopensCache = result;
  return result;
};

/**
 * Returns the first preopened directory, used as the "root" for high-level
 * file operations.
 * 
 * This is typically the current working directory (".") or the first `--dir`
 * flag passed to the WASI runtime.
 * 
 * @throws FsError if no directories were preopened.
 */
export let getRootDir = (): Descriptor => {
  let preopens = getPreopens();
  if (preopens.length == 0) {
    throw new FsError(FsErrorCode.NotFound, "No preopened directories available");
  }
  return preopens[0][0];
};

// ============================================================================
// High-Level Convenience Functions
// ============================================================================
//
// These functions operate relative to the first preopened directory (see
// `getRootDir()`). For access to other preopened directories, use
// `getPreopens()` and work with `Descriptor` objects directly.

/**
 * Reads the entire contents of a file as a UTF-8 string.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file doesn't exist or cannot be read.
 */
export let readFile = (path: string): string => {
  let root = getRootDir();
  let file = root.openAt(path, DescriptorFlags.Read);
  let content = file.readString();
  file.close();
  return content;
};

/**
 * Reads the entire contents of a file as raw bytes.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file doesn't exist or cannot be read.
 */
export let readFileBytes = (path: string): ByteArray => {
  let root = getRootDir();
  let file = root.openAt(path, DescriptorFlags.Read);
  let content = file.readAllBytes();
  file.close();
  return content;
};

/**
 * Writes a string to a file as UTF-8, creating or truncating the file.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file cannot be written (e.g., permission denied,
 *         directory doesn't exist, or read-only filesystem).
 */
export let writeFile = (path: string, content: string): void => {
  let root = getRootDir();
  let file = root.createAt(path);
  file.writeString(content);
  file.close();
};

/**
 * Writes raw bytes to a file, creating or truncating the file.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file cannot be written.
 */
export let writeFileBytes = (path: string, content: ByteArray): void => {
  let root = getRootDir();
  let file = root.createAt(path);
  file.writeBytes(content);
  file.close();
};

/**
 * Lists the contents of a directory.
 * 
 * The path is relative to the first preopened directory.
 * Use "." to list the root preopened directory itself.
 * 
 * @returns Array of directory entries with name and file type.
 * @throws FsError if the path doesn't exist or is not a directory.
 */
export let listDir = (path: string): Array<DirEntry> => {
  let root = getRootDir();
  let dir = root.openAt(path, DescriptorFlags.Read);
  let entries = dir.readDir();
  dir.close();
  return entries;
};

/**
 * Checks if a path exists (file or directory).
 * 
 * The path is relative to the first preopened directory.
 * 
 * @returns true if the path exists, false otherwise.
 */
export let exists = (path: string): boolean => {
  let root = getRootDir();
  return try {
    root.statAt(path);
    true
  } catch (e) {
    // Assume any error means doesn't exist (simplification)
    false
  };
};

/**
 * Checks if a path is a regular file.
 * 
 * @returns true if the path exists and is a file, false otherwise.
 */
export let isFile = (path: string): boolean => {
  let root = getRootDir();
  return try {
    let stat = root.statAt(path);
    stat.fileType == FileType.RegularFile
  } catch (e) {
    false
  };
};

/**
 * Checks if a path is a directory.
 * 
 * @returns true if the path exists and is a directory, false otherwise.
 */
export let isDirectory = (path: string): boolean => {
  let root = getRootDir();
  return try {
    let stat = root.statAt(path);
    stat.fileType == FileType.Directory
  } catch (e) {
    false
  };
};

/**
 * Creates a directory.
 * 
 * The path is relative to the first preopened directory.
 * Parent directories must already exist.
 * 
 * @throws FsError if the directory cannot be created.
 */
export let mkdir = (path: string): void => {
  let root = getRootDir();
  root.mkdirAt(path);
};

/**
 * Deletes a file.
 * 
 * The path is relative to the first preopened directory.
 * 
 * @throws FsError if the file doesn't exist or cannot be deleted.
 */
export let unlink = (path: string): void => {
  let root = getRootDir();
  root.unlinkAt(path);
};

/**
 * Deletes an empty directory.
 * 
 * The path is relative to the first preopened directory.
 * The directory must be empty.
 * 
 * @throws FsError if the directory doesn't exist, is not empty, or cannot
 *         be deleted.
 */
export let rmdir = (path: string): void => {
  let root = getRootDir();
  root.rmdirAt(path);
};
