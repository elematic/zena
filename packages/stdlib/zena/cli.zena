/**
 * CLI Standard Library - Command-Line Interface Utilities
 * 
 * Provides command-line argument parsing, environment variable access,
 * process control, and related utilities for CLI applications.
 * 
 * ## API Design Philosophy
 * 
 * This library's API is designed to closely mirror WASI Preview 2's CLI interfaces
 * (`wasi:cli/environment`, `wasi:cli/exit`) even though the current implementation
 * uses WASI Preview 1 under the hood. This ensures:
 * 
 * 1. Easy migration when Zena moves to WASI P2
 * 2. Familiar API for developers familiar with WASI
 * 3. Consistent with other WASI-based Zena standard libraries
 * 
 * ## WASI P2 Interface Mapping
 * 
 * | Zena API                 | WASI P2 Interface                     |
 * |--------------------------|---------------------------------------|
 * | getArguments()           | wasi:cli/environment.get-arguments    |
 * | getEnvironment()         | wasi:cli/environment.get-environment  |
 * | getEnv(name)             | (convenience wrapper)                 |
 * | initialCwd()             | wasi:cli/environment.initial-cwd      |
 * | exit(code)               | wasi:cli/exit.exit-with-code          |
 * 
 * ## WASI Preview 1 Implementation
 * 
 * Under the hood, this uses WASI Preview 1 functions:
 * - args_sizes_get, args_get - for command-line arguments
 * - environ_sizes_get, environ_get - for environment variables
 * - proc_exit - for process termination
 * 
 * ## Example
 * 
 * ```zena
 * import { getArguments, getEnv, exit, ExitCode } from 'zena:cli';
 * 
 * let main = () => {
 *   let args = getArguments();
 *   
 *   if (args.length < 2) {
 *     console.error("Usage: program <filename>");
 *     exit(ExitCode.Failure);
 *   }
 *   
 *   let verbose = getEnv("VERBOSE") != null;
 *   // ... process args[1] ...
 *   
 *   exit(ExitCode.Success);
 * };
 * ```
 */

import { String, Encoding } from 'zena:string';
import { Array } from 'zena:growable-array';
import { Memory, defaultAllocator } from 'zena:memory';
import { newByteArray } from 'zena:byte-array';

// ============================================================================
// Exit Codes
// ============================================================================

/**
 * Standard exit codes for CLI applications.
 * 
 * Maps to WASI P2's result-based exit where:
 * - Success (0) = Ok
 * - Failure (1) = Err with no specific code
 * 
 * Use `exit()` with these codes or a custom u8 value.
 */
export enum ExitCode {
  /** Successful program termination (code 0). */
  Success,
  
  /** Generic failure (code 1). */
  Failure,
  
  /** Invalid command-line arguments (code 2). */
  InvalidArguments,
  
  /** Resource not found (code 3). */
  NotFound,
  
  /** Permission denied (code 4). */
  PermissionDenied,
  
  /** I/O error (code 5). */
  IoError,
}

// ============================================================================
// WASI Preview 1 Bindings (Low-Level)
// ============================================================================

// Memory access
let mem = Memory.default;
let alloc = defaultAllocator;

// --- Command-line arguments ---

/**
 * Get the sizes needed for args_get.
 * @param argcPtr - Pointer to store argument count
 * @param argvBufSizePtr - Pointer to store total size of argument strings
 * @returns 0 on success, errno on failure
 */
@external("wasi_snapshot_preview1", "args_sizes_get")
declare function __wasi_args_sizes_get(argcPtr: i32, argvBufSizePtr: i32): i32;

/**
 * Read command-line arguments into memory.
 * @param argvPtr - Pointer to array of string pointers
 * @param argvBufPtr - Pointer to buffer for string data
 * @returns 0 on success, errno on failure
 */
@external("wasi_snapshot_preview1", "args_get")
declare function __wasi_args_get(argvPtr: i32, argvBufPtr: i32): i32;

// --- Environment variables ---

/**
 * Get the sizes needed for environ_get.
 * @param environCountPtr - Pointer to store environment variable count
 * @param environBufSizePtr - Pointer to store total size of environ strings
 * @returns 0 on success, errno on failure
 */
@external("wasi_snapshot_preview1", "environ_sizes_get")
declare function __wasi_environ_sizes_get(environCountPtr: i32, environBufSizePtr: i32): i32;

/**
 * Read environment variables into memory.
 * @param environPtr - Pointer to array of string pointers
 * @param environBufPtr - Pointer to buffer for string data
 * @returns 0 on success, errno on failure
 */
@external("wasi_snapshot_preview1", "environ_get")
declare function __wasi_environ_get(environPtr: i32, environBufPtr: i32): i32;

// --- Process control ---

/**
 * Terminate the process with the given exit code.
 * This function does not return.
 */
@external("wasi_snapshot_preview1", "proc_exit")
declare function __wasi_proc_exit(code: i32): void;

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Helper to allocate memory or panic.
 * For CLI operations, failing to allocate is typically unrecoverable.
 */
let allocOrPanic = (size: i32): i32 => {
  if (let (true, ptr) = alloc.alloc(size)) {
    return ptr;
  }
  // TODO: When panic is available, use it
  __wasi_proc_exit(1);
  // Unreachable, but needed for type checker
  return 0;
};

/**
 * Read a null-terminated string from linear memory.
 * @param ptr - Pointer to the start of the string
 * @returns A Zena string
 */
let readCString = (ptr: i32): string => {
  // Find the null terminator
  var len = 0;
  while (mem.getU8(ptr + len) != 0) {
    len = len + 1;
  }
  
  // Build a GC byte array from linear memory
  let bytes = newByteArray(len);
  for (var i = 0; i < len; i = i + 1) {
    __byte_array_set(bytes, i, mem.getU8(ptr + i));
  }
  // Create string from the byte array
  return String.fromByteArray(bytes, 0, len, Encoding.WTF8);
};

/**
 * Read a string with known length from linear memory.
 * @param ptr - Pointer to the start of the string
 * @param len - Length of the string in bytes
 * @returns A Zena string
 */
let readStringWithLength = (ptr: i32, len: i32): string => {
  // Build a GC byte array from linear memory
  let bytes = newByteArray(len);
  for (var i = 0; i < len; i = i + 1) {
    __byte_array_set(bytes, i, mem.getU8(ptr + i));
  }
  return String.fromByteArray(bytes, 0, len, Encoding.WTF8);
};

// ============================================================================
// Environment Variables (wasi:cli/environment)
// ============================================================================

/**
 * A key-value pair representing an environment variable.
 * Matches WASI P2's tuple<string, string> representation.
 */
export type EnvVar = {
  name: string,
  value: string,
};

/**
 * Get all environment variables.
 * 
 * Returns a list of (name, value) pairs for all environment variables
 * available to the process.
 * 
 * Maps to: `wasi:cli/environment.get-environment`
 * 
 * @returns Array of environment variable key-value pairs
 * 
 * @example
 * ```zena
 * for (let env in getEnvironment()) {
 *   console.log(env.name + "=" + env.value);
 * }
 * ```
 */
export let getEnvironment = (): Array<EnvVar> => {
  // Step 1: Get sizes
  let countPtr = allocOrPanic(4);
  let bufSizePtr = allocOrPanic(4);
  
  var errno = __wasi_environ_sizes_get(countPtr, bufSizePtr);
  if (errno != 0) {
    alloc.free(countPtr);
    alloc.free(bufSizePtr);
    return new Array<EnvVar>();
  }
  
  let count = mem.getI32(countPtr);
  let bufSize = mem.getI32(bufSizePtr);
  alloc.free(countPtr);
  alloc.free(bufSizePtr);
  
  if (count == 0) {
    return new Array<EnvVar>();
  }
  
  // Step 2: Allocate buffers
  let environPtr = allocOrPanic(count * 4);  // Array of i32 pointers
  let environBufPtr = allocOrPanic(bufSize);
  
  // Step 3: Get the environment
  errno = __wasi_environ_get(environPtr, environBufPtr);
  if (errno != 0) {
    alloc.free(environPtr);
    alloc.free(environBufPtr);
    return new Array<EnvVar>();
  }
  
  // Step 4: Parse into array
  let result = new Array<EnvVar>();
  
  for (var i = 0; i < count; i = i + 1) {
    let strPtr = mem.getI32(environPtr + i * 4);
    let envStr = readCString(strPtr);
    
    // Parse "NAME=VALUE" format - find '=' (byte 61)
    var eqIndex = 0 - 1;
    for (var j = 0; j < envStr.length; j = j + 1) {
      if (envStr.getByteAt(j) == 61) {
        eqIndex = j;
        j = envStr.length;  // break
      }
    }
    if (eqIndex >= 0) {
      let name = envStr.sliceBytes(0, eqIndex);
      let value = envStr.sliceBytes(eqIndex + 1, envStr.length);
      result.push({ name: name, value: value });
    }
  }
  
  // Step 5: Cleanup
  alloc.free(environPtr);
  alloc.free(environBufPtr);
  
  return result;
};

/**
 * Get a single environment variable by name.
 * 
 * This is a convenience wrapper around `getEnvironment()` for the common
 * case of looking up a single variable.
 * 
 * @param name - The name of the environment variable to look up
 * @returns The value if found, or null if not found
 * 
 * @example
 * ```zena
 * let home = getEnv("HOME");
 * if (home != null) {
 *   console.log("Home directory: " + home);
 * }
 * 
 * // Or with default value pattern:
 * let port = getEnv("PORT") ?? "8080";
 * ```
 */
export let getEnv = (name: string): string | null => {
  let envs = getEnvironment();
  for (var i = 0; i < envs.length; i = i + 1) {
    let env = envs[i];
    if (env.name == name) {
      return env.value;
    }
  }
  return null;
};

// ============================================================================
// Command-Line Arguments (wasi:cli/environment)
// ============================================================================

/**
 * Get the command-line arguments passed to the program.
 * 
 * Returns all arguments including the program name (typically at index 0).
 * 
 * Maps to: `wasi:cli/environment.get-arguments`
 * 
 * @returns Array of argument strings
 * 
 * @example
 * ```zena
 * let args = getArguments();
 * 
 * // args[0] is typically the program name
 * console.log("Program: " + args[0]);
 * 
 * // Process remaining arguments
 * for (var i = 1; i < args.length; i = i + 1) {
 *   console.log("Arg: " + args[i]);
 * }
 * ```
 */
export let getArguments = (): Array<string> => {
  // Step 1: Get sizes
  let argcPtr = allocOrPanic(4);
  let argvBufSizePtr = allocOrPanic(4);
  
  var errno = __wasi_args_sizes_get(argcPtr, argvBufSizePtr);
  if (errno != 0) {
    alloc.free(argcPtr);
    alloc.free(argvBufSizePtr);
    return new Array<string>();
  }
  
  let argc = mem.getI32(argcPtr);
  let argvBufSize = mem.getI32(argvBufSizePtr);
  alloc.free(argcPtr);
  alloc.free(argvBufSizePtr);
  
  if (argc == 0) {
    return new Array<string>();
  }
  
  // Step 2: Allocate buffers
  let argvPtr = allocOrPanic(argc * 4);  // Array of i32 pointers
  let argvBufPtr = allocOrPanic(argvBufSize);
  
  // Step 3: Get the arguments
  errno = __wasi_args_get(argvPtr, argvBufPtr);
  if (errno != 0) {
    alloc.free(argvPtr);
    alloc.free(argvBufPtr);
    return new Array<string>();
  }
  
  // Step 4: Parse into array
  let result = new Array<string>();
  
  for (var i = 0; i < argc; i = i + 1) {
    let strPtr = mem.getI32(argvPtr + i * 4);
    let arg = readCString(strPtr);
    result.push(arg);
  }
  
  // Step 5: Cleanup
  alloc.free(argvPtr);
  alloc.free(argvBufPtr);
  
  return result;
};

/**
 * Get the program name (first argument).
 * 
 * Convenience function to get just the program name without loading
 * all arguments.
 * 
 * @returns The program name, or an empty string if not available
 * 
 * @example
 * ```zena
 * console.log("Usage: " + getProgramName() + " [options] <file>");
 * ```
 */
export let getProgramName = (): string => {
  let args = getArguments();
  if (args.length > 0) {
    return args[0];
  }
  return "";
};

// ============================================================================
// Current Working Directory (wasi:cli/environment)
// ============================================================================

/**
 * Get the initial current working directory.
 * 
 * Returns the path that programs should use as their initial working
 * directory, interpreting `.` as shorthand for this path.
 * 
 * Maps to: `wasi:cli/environment.initial-cwd`
 * 
 * Note: WASI Preview 1 does not have a direct equivalent. This function
 * may return null if the runtime doesn't provide CWD information through
 * environment variables or other means.
 * 
 * @returns The initial CWD if available, or null
 * 
 * @example
 * ```zena
 * let cwd = initialCwd();
 * if (cwd != null) {
 *   console.log("Current directory: " + cwd);
 * }
 * ```
 */
export let initialCwd = (): string | null => {
  // WASI P1 doesn't have a direct API for this.
  // Common convention: check PWD environment variable
  return getEnv("PWD");
};

// ============================================================================
// Process Exit (wasi:cli/exit)
// ============================================================================

/**
 * Exit the program with the specified exit code.
 * 
 * This function does not return. It immediately terminates the process
 * with the given status code.
 * 
 * Maps to: `wasi:cli/exit.exit-with-code`
 * 
 * Exit code conventions:
 * - 0: Success
 * - 1: General failure
 * - 2: Misuse of shell command / invalid arguments
 * - 126: Command invoked cannot execute
 * - 127: Command not found
 * - 128+N: Fatal error signal N
 * 
 * @param code - The exit code (0-255). Use ExitCode enum for common cases.
 * 
 * @example
 * ```zena
 * // Using enum
 * exit(ExitCode.Success);
 * 
 * // Using numeric code
 * exit(0);
 * 
 * // Error exit
 * console.error("Fatal error occurred");
 * exit(ExitCode.Failure);
 * ```
 */
export let exit = (code: i32): void => {
  __wasi_proc_exit(code);
};

/**
 * Exit successfully (code 0).
 * 
 * Convenience function for successful program termination.
 * Equivalent to `exit(ExitCode.Success)`.
 * 
 * Maps to: `wasi:cli/exit.exit` with Ok result
 */
export let exitSuccess = (): void => {
  __wasi_proc_exit(0);
};

/**
 * Exit with failure (code 1).
 * 
 * Convenience function for failed program termination.
 * Equivalent to `exit(ExitCode.Failure)`.
 * 
 * Maps to: `wasi:cli/exit.exit` with Err result
 */
export let exitFailure = (): void => {
  __wasi_proc_exit(1);
};

// ============================================================================
// Argument Parsing Utilities
// ============================================================================

/**
 * Result of parsing a command-line option.
 */
export type ParsedOption = {
  /** The option name (without leading dashes). */
  name: string,
  /** The option value, if provided (for --name=value or -n value). Null if no value. */
  value: string | null
};

/**
 * Check if an argument is a short option (e.g., -v, -h).
 * 
 * @param arg - The argument to check
 * @returns true if it's a short option (single dash + single char)
 */
export let isShortOption = (arg: string): boolean => {
  // Short option: exactly "-X" where X is not '-' (45 = '-')
  if (arg.length != 2) {
    return false;
  }
  if (arg.getByteAt(0) != 45) {
    return false;
  }
  if (arg.getByteAt(1) == 45) {
    return false;
  }
  return true;
};

/**
 * Check if an argument is a long option (e.g., --verbose, --help).
 * 
 * @param arg - The argument to check
 * @returns true if it's a long option (starts with --)
 */
export let isLongOption = (arg: string): boolean => {
  // Long option: starts with "--" (45 = '-') and has at least one more char
  if (arg.length < 3) {
    return false;
  }
  if (arg.getByteAt(0) != 45 || arg.getByteAt(1) != 45) {
    return false;
  }
  return true;
};

/**
 * Check if an argument is any kind of option (short or long).
 * 
 * @param arg - The argument to check
 * @returns true if it starts with a dash
 */
export let isOption = (arg: string): boolean => {
  // Any option starts with '-' (byte 45)
  if (arg.length == 0) {
    return false;
  }
  return arg.getByteAt(0) == 45;
};

/**
 * Parse a long option that may have a value (--name=value).
 * 
 * @param arg - The argument to parse (should start with --)
 * @returns ParsedOption with name and optional value
 * 
 * @example
 * ```zena
 * let opt = parseLongOption("--output=file.txt");
 * // opt.name == "output", opt.value == "file.txt"
 * 
 * let opt2 = parseLongOption("--verbose");
 * // opt2.name == "verbose", opt2.value == null
 * ```
 */
export let parseLongOption = (arg: string): ParsedOption => {
  // Remove leading --
  let optPart = arg.sliceBytes(2, arg.length);
  
  // Check for = separator (byte 61)
  var eqIndex = 0 - 1;
  for (var i = 0; i < optPart.length; i = i + 1) {
    if (optPart.getByteAt(i) == 61) {
      eqIndex = i;
      i = optPart.length;  // break
    }
  }
  if (eqIndex >= 0) {
    return {
      name: optPart.sliceBytes(0, eqIndex),
      value: optPart.sliceBytes(eqIndex + 1, optPart.length)
    };
  }
  
  return { name: optPart, value: null };
};

// ============================================================================
// Signal Handling (Future WASI Extension)
// ============================================================================

// Note: WASI Preview 2 does not yet have a standard interface for signal
// handling (Ctrl+C, SIGTERM, etc.). When wasi:signals or similar is
// standardized, we will add support here.
//
// The API will likely look something like:
//
// ```zena
// export type Signal = Interrupt | Terminate | Hangup | ...;
// 
// export let onSignal = (signal: Signal, handler: () => void): void => {
//   // Register signal handler
// };
// ```
//
// For now, Ctrl+C and other signals are handled by the runtime and will
// terminate the process with a non-zero exit code.
