// String conversion functions for primitive types
// These provide both low-level buffer writing (for StringBuilder) and
// high-level String creation (for template literals).

import { String, Encoding } from 'zena:string';
import { div, I32_MIN, I64_MIN } from 'zena:math';

// ============================================================================
// Low-level buffer writing functions
// These write to a pre-allocated ByteArray and return (startPos, endPos).
// They write digits in reverse from the end of the buffer.
// The caller must provide a buffer of sufficient size.
// ============================================================================

/**
 * Writes an i32 to a buffer. Buffer must have at least 11 bytes.
 * Returns (startPos, endPos) where the digits are in buffer[startPos..endPos).
 */
export let writeI32 = (value: i32, buffer: ByteArray, bufferEnd: i32): (i32, i32) => {
  if (value == 0) {
    __byte_array_set(buffer, bufferEnd - 1, 48);
    return (bufferEnd - 1, bufferEnd);
  }
  
  if (value == I32_MIN) {
    // Special case: -2147483648 can't be negated without overflow
    let minStr = "-2147483648";
    let start = bufferEnd - 11;
    // TODO: Add a __string_get_bytes intrinsic to avoid creating a temporary
    // String object here
    minStr.copyBytesTo(buffer, start);
    return (start, bufferEnd);
  }
  
  let isNegative = value < 0;
  var absValue = value;
  if (isNegative) {
    absValue = 0 - value;
  }
  
  var pos = bufferEnd;
  while (absValue > 0) {
    pos = pos - 1;
    __byte_array_set(buffer, pos, 48 + (absValue - div(absValue, 10) * 10));
    absValue = div(absValue, 10);
  }
  
  if (isNegative) {
    pos = pos - 1;
    __byte_array_set(buffer, pos, 45);
  }
  
  return (pos, bufferEnd);
};

/**
 * Writes a u32 to a buffer. Buffer must have at least 10 bytes.
 * Returns (startPos, endPos).
 */
export let writeU32 = (value: u32, buffer: ByteArray, bufferEnd: i32): (i32, i32) => {
  let zero: u32 = 0 as u32;
  if (value == zero) {
    __byte_array_set(buffer, bufferEnd - 1, 48);
    return (bufferEnd - 1, bufferEnd);
  }
  
  var v = value;
  var pos = bufferEnd;
  while (v > zero) {
    pos = pos - 1;
    let digit = v - div(v, 10 as u32) * (10 as u32);
    __byte_array_set(buffer, pos, 48 + (digit as i32));
    v = div(v, 10 as u32);
  }
  
  return (pos, bufferEnd);
};

/**
 * Writes an i64 to a buffer. Buffer must have at least 20 bytes.
 * Returns (startPos, endPos).
 */
export let writeI64 = (value: i64, buffer: ByteArray, bufferEnd: i32): (i32, i32) => {
  let zero: i64 = 0 as i64;
  if (value == zero) {
    __byte_array_set(buffer, bufferEnd - 1, 48);
    return (bufferEnd - 1, bufferEnd);
  }
  
  if (value == I64_MIN) {
    // Special case: -9223372036854775808 can't be negated without overflow
    let minStr = "-9223372036854775808";
    let start = bufferEnd - 20;
    minStr.copyBytesTo(buffer, start);
    return (start, bufferEnd);
  }
  
  let isNegative = value < zero;
  var absValue = value;
  if (isNegative) {
    absValue = zero - value;
  }
  
  var pos = bufferEnd;
  while (absValue > zero) {
    pos = pos - 1;
    let digit = absValue - div(absValue, 10 as i64) * (10 as i64);
    __byte_array_set(buffer, pos, 48 + (digit as i32));
    absValue = div(absValue, 10 as i64);
  }
  
  if (isNegative) {
    pos = pos - 1;
    __byte_array_set(buffer, pos, 45);
  }
  
  return (pos, bufferEnd);
};

/**
 * Writes a u64 to a buffer. Buffer must have at least 20 bytes.
 * Returns (startPos, endPos).
 */
export let writeU64 = (value: u64, buffer: ByteArray, bufferEnd: i32): (i32, i32) => {
  let zero: u64 = 0 as u64;
  if (value == zero) {
    __byte_array_set(buffer, bufferEnd - 1, 48);
    return (bufferEnd - 1, bufferEnd);
  }
  
  var v = value;
  var pos = bufferEnd;
  while (v > zero) {
    pos = pos - 1;
    let digit = v - div(v, 10 as u64) * (10 as u64);
    __byte_array_set(buffer, pos, 48 + (digit as i32));
    v = div(v, 10 as u64);
  }
  
  return (pos, bufferEnd);
};

// ============================================================================
// High-level String conversion functions
// Used by template literals for automatic primitive-to-string conversion.
// ============================================================================

/**
 * Converts an i32 to its decimal string representation.
 */
export let i32ToString = (value: i32): String => {
  if (value == I32_MIN) {
    return "-2147483648";
  }
  let buffer = __byte_array_new(12);
  let (start, end) = writeI32(value, buffer, 12);
  return String.fromByteArray(buffer, start, end, Encoding.WTF8);
};

/**
 * Converts a u32 to its decimal string representation.
 */
export let u32ToString = (value: u32): String => {
  let buffer = __byte_array_new(11);
  let (start, end) = writeU32(value, buffer, 11);
  return String.fromByteArray(buffer, start, end, Encoding.WTF8);
};

/**
 * Converts an i64 to its decimal string representation.
 */
export let i64ToString = (value: i64): String => {
  if (value == I64_MIN) {
    return "-9223372036854775808";
  }
  let buffer = __byte_array_new(21);
  let (start, end) = writeI64(value, buffer, 21);
  return String.fromByteArray(buffer, start, end, Encoding.WTF8);
};

/**
 * Converts a u64 to its decimal string representation.
 */
export let u64ToString = (value: u64): String => {
  let buffer = __byte_array_new(21);
  let (start, end) = writeU64(value, buffer, 21);
  return String.fromByteArray(buffer, start, end, Encoding.WTF8);
};

/**
 * Converts a bool to "true" or "false".
 */
export let boolToString = (value: boolean): String => {
  if (value) {
    return "true";
  }
  return "false";
};

/**
 * Converts an f32 to string.
 * TODO: Proper float formatting
 */
export let f32ToString = (value: f32): String => {
  // For now, just handle a few special cases
  // Full float formatting is complex - would need Dragon4 or similar algorithm
  if (value != value) {
    return "NaN";
  }
  // TODO: Implement proper float to string conversion
  return "[f32]";
};

/**
 * Converts an f64 to string.
 * TODO: Proper float formatting
 */
export let f64ToString = (value: f64): String => {
  if (value != value) {
    return "NaN";
  }
  // TODO: Implement proper float to string conversion
  return "[f64]";
};
