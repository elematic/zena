import { FixedArray } from 'zena:fixed-array';
import { KeyNotFoundError } from 'zena:error';
import { Option, some, none } from 'zena:option';
import { Iterable, Iterator } from 'zena:iterator';

export interface Hashable {
  hashCode(): i32;
  operator ==(other: Hashable): boolean;
}

@intrinsic('hash')
export declare function hash<T>(value: T): i32;

@intrinsic('eq')
export declare function equals<T>(a: T, b: T): boolean;

// Symbols for MapEntry storage (exposed via getters)
symbol mapEntryKey;
symbol mapEntryValue;

class Entry<K, V> {
  key: K;
  value: V;
  next: Entry<K, V> | null;

  #new(key: K, value: V, next: Entry<K, V> | null) {
    this.key = key;
    this.value = value;
    this.next = next;
  }
}

/**
 * A key-value pair from a Map.
 */
export class MapEntry<K, V> {
  :mapEntryKey: K;
  :mapEntryValue: V;

  #new(key: K, value: V) {
    this.:mapEntryKey = key;
    this.:mapEntryValue = value;
  }

  key: K {
    get {
      return this.:mapEntryKey;
    }
  }

  value: V {
    get {
      return this.:mapEntryValue;
    }
  }
}

/**
 * Iterator over the keys of a Map.
 */
class MapKeyIterator<K, V> implements Iterator<K> {
  #buckets: FixedArray<Entry<K, V> | null>;
  #bucketIndex: i32;
  #current: Entry<K, V> | null;

  #new(buckets: FixedArray<Entry<K, V> | null>) {
    this.#buckets = buckets;
    this.#bucketIndex = 0;
    this.#current = null;
    this.#advanceToNext();
  }

  #advanceToNext(): void {
    if (this.#current != null) {
      let entry = this.#current as Entry<K, V>;
      if (entry.next != null) {
        this.#current = entry.next;
        return;
      }
    }
    this.#current = null;
    while (this.#bucketIndex < this.#buckets.length) {
      let bucket = this.#buckets[this.#bucketIndex];
      this.#bucketIndex = this.#bucketIndex + 1;
      if (bucket != null) {
        this.#current = bucket;
        return;
      }
    }
  }

  next(): (true, K) | (false, never) {
    if (this.#current == null) {
      return (false, _);
    }
    let entry = this.#current as Entry<K, V>;
    let key = entry.key;
    this.#advanceToNext();
    return (true, key);
  }
}

/**
 * Iterator over the entries of a Map.
 */
class MapEntryIterator<K, V> implements Iterator<MapEntry<K, V>> {
  #buckets: FixedArray<Entry<K, V> | null>;
  #bucketIndex: i32;
  #current: Entry<K, V> | null;

  #new(buckets: FixedArray<Entry<K, V> | null>) {
    this.#buckets = buckets;
    this.#bucketIndex = 0;
    this.#current = null;
    this.#advanceToNext();
  }

  #advanceToNext(): void {
    if (this.#current != null) {
      let entry = this.#current as Entry<K, V>;
      if (entry.next != null) {
        this.#current = entry.next;
        return;
      }
    }
    this.#current = null;
    while (this.#bucketIndex < this.#buckets.length) {
      let bucket = this.#buckets[this.#bucketIndex];
      this.#bucketIndex = this.#bucketIndex + 1;
      if (bucket != null) {
        this.#current = bucket;
        return;
      }
    }
  }

  next(): (true, MapEntry<K, V>) | (false, never) {
    if (this.#current == null) {
      return (false, _);
    }
    let entry = this.#current as Entry<K, V>;
    let result = new MapEntry<K, V>(entry.key, entry.value);
    this.#advanceToNext();
    return (true, result);
  }
}

export class Map<K, V> implements Iterable<MapEntry<K, V>> {
  #buckets: FixedArray<Entry<K, V> | null>;
  #size: i32 = 0;

  #new(capacity: i32 = 16) {
    this.#buckets = __array_new_empty<Entry<K, V> | null>(capacity);
  }

  size: i32 {
    get {
      return this.#size;
    }
  }

  operator []=(key: K, value: V): void {
    if (this.#size * 4 >= this.#buckets.length * 3) {
      this.#resize();
    }

    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    let head = this.#buckets[index];
    var current = head;
    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        entry.value = value;
        return;
      }
      current = entry.next;
    }

    let newEntry = new Entry(key, value, head);
    this.#buckets[index] = newEntry;
    this.#size = this.#size + 1;
  }

  /**
   * Gets the value for a key. Throws KeyNotFoundError if the key doesn't exist.
   * Use this when you expect the key to exist.
   */
  operator [](key: K): V {
    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    var current = this.#buckets[index];
    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        return entry.value;
      }
      current = entry.next;
    }
    throw new KeyNotFoundError();
  }

  /**
   * Gets the value for a key, returning (value, true) if found or (_, false) if not.
   * This is the preferred method for checking if a key exists and getting its value,
   * as it has zero allocation overhead. The first element is undefined when not found
   * and must not be accessed.
   */
  get(key: K): (V, boolean) {
    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    var current = this.#buckets[index];
    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        return (entry.value, true);
      }
      current = entry.next;
    }
    return (_, false);
  }

  /**
   * Gets the value for a key, or returns the default value if not found.
   */
  getOr(key: K, defaultValue: V): V {
    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    var current = this.#buckets[index];
    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        return entry.value;
      }
      current = entry.next;
    }
    return defaultValue;
  }

  /**
   * Finds the value for a key, returning Some(value) if found or None if not.
   * Use this when you need to store or pass around the optional result.
   */
  find(key: K): Option<V> {
    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    var current = this.#buckets[index];
    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        return some(entry.value);
      }
      current = entry.next;
    }
    return none;
  }

  has(key: K): boolean {
    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    var current = this.#buckets[index];
    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        return true;
      }
      current = entry.next;
    }
    return false;
  }

  delete(key: K): boolean {
    let h = hash(key);
    let len = this.#buckets.length;
    var index = h % len;
    if (index < 0) index = index + len;

    let head = this.#buckets[index];
    var current = head;
    var prev: Entry<K, V> | null = null;

    while (current != null) {
      let entry = current as Entry<K, V>;
      if (equals(entry.key, key)) {
        if (prev == null) {
          this.#buckets[index] = entry.next;
        } else {
          (prev as Entry<K, V>).next = entry.next;
        }
        this.#size = this.#size - 1;
        return true;
      }
      prev = current;
      current = entry.next;
    }
    return false;
  }

  clear(): void {
    this.#buckets = __array_new_empty<Entry<K, V> | null>(16);
    this.#size = 0;
  }

  #resize(): void {
    let oldBuckets = this.#buckets;
    let newCapacity = oldBuckets.length * 2;
    this.#buckets = __array_new_empty<Entry<K, V> | null>(newCapacity);
    this.#size = 0;

    var i = 0;
    while (i < oldBuckets.length) {
      var current = oldBuckets[i];
      while (current != null) {
        let entry = current as Entry<K, V>;
        this[entry.key] = entry.value;
        current = entry.next;
      }
      i = i + 1;
    }
  }

  // Add set method for compatibility/convenience
  set(key: K, value: V): void {
    this[key] = value;
  }

  /**
   * Returns an iterator over the keys in this map.
   */
  keys(): Iterator<K> {
    return new MapKeyIterator<K, V>(this.#buckets);
  }

  /**
   * Returns an iterator over the entries in this map.
   */
  :Iterable.iterator(): Iterator<MapEntry<K, V>> {
    return new MapEntryIterator<K, V>(this.#buckets);
  }
  
  /*
   * Calls the callback function for each key-value pair in the map.
   */
  forEach(callback: (key: K, value: V) => void): void {
    var i = 0;
    while (i < this.#buckets.length) {
      var current = this.#buckets[i];
      while (current != null) {
        let entry = current as Entry<K, V>;
        callback(entry.key, entry.value);
        current = entry.next;
      }
      i = i + 1;
    }
  }
}
