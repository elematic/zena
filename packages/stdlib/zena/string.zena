// String class - view-based design (like Go)
// Every String is a view into a backing ByteArray with start/end offsets.
// Slicing is O(1) and zero-copy. Use copy() to release parent memory.
//
// SAFETY: Use StringReader for parsing to ensure slices are at code point
// boundaries. Direct use of sliceBytes() with computed indices can split
// multi-byte UTF-8 sequences.

export enum Encoding {
  WTF8,    // 0 - UTF-8 with unpaired surrogates allowed
  WTF16    // 1 - UTF-16 for JS interop
}

export final class String {
  // Internal storage - accessed by compiler intrinsics
  #data: ByteArray;    // Backing storage (may be shared with other Strings)
  #start: i32;         // Start offset into #data (inclusive)
  #end: i32;           // End offset into #data (exclusive)
  #encoding: Encoding;

  // Private constructor - strings are created by the compiler for literals
  // or by StringBuilder/transcoding functions
  #new(data: ByteArray, start: i32, end: i32, encoding: Encoding) {
    this.#data = data;
    this.#start = start;
    this.#end = end;
    this.#encoding = encoding;
  }

  /**
   * Creates a new string by concatenating all parts.
   * This is more efficient than chained + operators for multiple strings,
   * as it allocates the result array only once.
   *
   * Used internally by template literals.
   */
  static fromParts(parts: array<String>): String {
    // First pass: calculate total length
    let partsLen = __array_len(parts);
    var totalLen = 0;
    var i = 0;
    while (i < partsLen) {
      let part = __array_get(parts, i);
      totalLen = totalLen + (part.#end - part.#start);
      i = i + 1;
    }

    // Allocate result array
    let data = __byte_array_new(totalLen);

    // Second pass: copy all parts
    var offset = 0;
    i = 0;
    while (i < partsLen) {
      let part = __array_get(parts, i);
      let partLen = part.#end - part.#start;
      __byte_array_copy(data, offset, part.#data, part.#start, partLen);
      offset = offset + partLen;
      i = i + 1;
    }

    // Use encoding from first part, or default to WTF-8
    var encoding = Encoding.WTF8;
    if (partsLen > 0) {
      encoding = __array_get(parts, 0).#encoding;
    }
    return new String(data, 0, totalLen, encoding);
  }

  // Length in bytes (code units for WTF-8).
  // For ASCII and most UTF-8, this equals the number of characters.
  // TODO: For WTF-16, return code units (byteLen / 2) once integer division is supported.
  length: i32 {
    get {
      return this.#end - this.#start;
    }
  }

  // Get byte at index (relative to this view). Returns the byte value as i32.
  // For WTF-8 strings, this is the UTF-8 byte at the given index.
  // For WTF-16 strings, this is the byte (not code unit) at the given index.
  getByteAt(index: i32): i32 {
    return __byte_array_get(this.#data, this.#start + index);
  }

  /**
   * O(1) zero-copy slice by byte indices.
   * Returns a new String sharing the backing array.
   * 
   * SAFETY: Indices are byte offsets, not code point offsets.
   * Slicing in the middle of a multi-byte UTF-8 sequence produces
   * an invalid string. Use StringReader.mark() to get safe positions.
   */
  sliceBytes(start: i32, end: i32): String {
    // Clamp indices to valid range
    var s = start;
    var e = end;
    let len = this.#end - this.#start;
    if (s < 0) { s = 0; }
    if (e > len) { e = len; }
    if (s > e) { s = e; }
    
    return new String(
      this.#data,
      this.#start + s,
      this.#start + e,
      this.#encoding
    );
  }

  // Force a copy - creates a new String with its own backing array.
  // Use this when you need to release the parent string's memory.
  copy(): String {
    let len = this.#end - this.#start;
    let newData = __byte_array_new(len);
    __byte_array_copy(newData, 0, this.#data, this.#start, len);
    return new String(newData, 0, len, this.#encoding);
  }

  // Concatenation operator - always allocates a new backing array
  operator +(other: String): String {
    let len1 = this.#end - this.#start;
    let len2 = other.#end - other.#start;
    let newData = __byte_array_new(len1 + len2);
    __byte_array_copy(newData, 0, this.#data, this.#start, len1);
    __byte_array_copy(newData, len1, other.#data, other.#start, len2);
    return new String(newData, 0, len1 + len2, this.#encoding);
  }

  // Equality operator - compares the bytes in each view
  operator ==(other: String): boolean {
    let len1 = this.#end - this.#start;
    let len2 = other.#end - other.#start;

    // Quick length check
    if (len1 != len2) {
      return false;
    }

    // Compare bytes
    var i = 0;
    while (i < len1) {
      if (__byte_array_get(this.#data, this.#start + i) != __byte_array_get(other.#data, other.#start + i)) {
        return false;
      }
      i = i + 1;
    }
    return true;
  }

  // String hash is implemented by the compiler in codegen/expressions.ts:
  // - generateStringHashFunction: extracts #data, #start, #end, FNV-1a hash bytes
}
