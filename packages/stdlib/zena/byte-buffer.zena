/**
 * ByteBuffer - A growable buffer for efficiently constructing binary data.
 * 
 * Uses a chunked growth strategy (like StringBuilder) to avoid copying
 * on every resize. Ideal for building binary formats like WASM modules.
 */

import { Array } from 'zena:growable-array';
import { i32_reinterpret_f32, i64_reinterpret_f64 } from 'zena:math';

/**
 * A growable buffer for efficiently constructing binary data.
 */
export final class ByteBuffer {
  #chunks: Array<ByteArray>;
  #currentChunk: ByteArray;
  #currentPos: i32;
  #totalLength: i32;

  /**
   * Creates a new ByteBuffer with the specified initial chunk capacity.
   * @param capacity Initial capacity for the first chunk (default: 256).
   */
  #new(capacity: i32 = 256) {
    var cap = capacity;
    if (cap <= 0) {
      cap = 256;
    }
    this.#chunks = new Array<ByteArray>();
    this.#currentChunk = __byte_array_new(cap);
    this.#currentPos = 0;
    this.#totalLength = 0;
  }

  /**
   * Total number of bytes written to the buffer.
   */
  length: i32 {
    get {
      return this.#totalLength + this.#currentPos;
    }
  }

  /**
   * Total allocated capacity across all chunks.
   */
  capacity: i32 {
    get {
      var cap = 0;
      var i = 0;
      while (i < this.#chunks.length) {
        cap = cap + __byte_array_length(this.#chunks[i]);
        i = i + 1;
      }
      cap = cap + __byte_array_length(this.#currentChunk);
      return cap;
    }
  }

  //===------------------------------------------------------------------===//
  // Core Write Operations
  //===------------------------------------------------------------------===//

  /**
   * Write a single byte.
   */
  writeByte(b: i32): ByteBuffer {
    this.#ensureSpace(1);
    __byte_array_set(this.#currentChunk, this.#currentPos, b);
    this.#currentPos = this.#currentPos + 1;
    return this;
  }

  /**
   * Write all bytes from a ByteArray.
   */
  writeBytes(src: ByteArray): ByteBuffer {
    return this.writeBytesSlice(src, 0, __byte_array_length(src));
  }

  /**
   * Write a slice of bytes from a ByteArray.
   * @param src Source byte array
   * @param offset Starting offset in source
   * @param len Number of bytes to write
   */
  writeBytesSlice(src: ByteArray, offset: i32, len: i32): ByteBuffer {
    var remaining = len;
    var srcOffset = offset;

    while (remaining > 0) {
      let available = this.#ensureSpace(remaining);
      var toCopy = remaining;
      if (toCopy > available) {
        toCopy = available;
      }

      __byte_array_copy(this.#currentChunk, this.#currentPos, src, srcOffset, toCopy);
      this.#currentPos = this.#currentPos + toCopy;
      srcOffset = srcOffset + toCopy;
      remaining = remaining - toCopy;
    }
    return this;
  }

  /**
   * Write another ByteBuffer's contents.
   */
  writeBuffer(other: ByteBuffer): ByteBuffer {
    // Copy all full chunks
    var i = 0;
    while (i < other.#chunks.length) {
      this.writeBytes(other.#chunks[i]);
      i = i + 1;
    }
    // Copy current chunk portion
    if (other.#currentPos > 0) {
      this.writeBytesSlice(other.#currentChunk, 0, other.#currentPos);
    }
    return this;
  }

  //===------------------------------------------------------------------===//
  // Typed Write Operations (Little-Endian)
  //===------------------------------------------------------------------===//

  /**
   * Write a 16-bit unsigned integer (little-endian).
   */
  writeU16(value: i32): ByteBuffer {
    this.writeByte(value & 0xFF);
    this.writeByte((value >> 8) & 0xFF);
    return this;
  }

  /**
   * Write a 32-bit unsigned integer (little-endian).
   */
  writeU32(value: i32): ByteBuffer {
    this.writeByte(value & 0xFF);
    this.writeByte((value >> 8) & 0xFF);
    this.writeByte((value >> 16) & 0xFF);
    this.writeByte((value >> 24) & 0xFF);
    return this;
  }

  /**
   * Write a 64-bit integer (little-endian).
   */
  writeU64(value: i64): ByteBuffer {
    this.writeU32(value as i32);
    this.writeU32((value >> 32) as i32);
    return this;
  }

  /**
   * Write a 32-bit float (little-endian).
   */
  writeF32(value: f32): ByteBuffer {
    let bits = i32_reinterpret_f32(value);
    return this.writeU32(bits);
  }

  /**
   * Write a 64-bit float (little-endian).
   */
  writeF64(value: f64): ByteBuffer {
    let bits = i64_reinterpret_f64(value);
    return this.writeU64(bits);
  }

  //===------------------------------------------------------------------===//
  // LEB128 Encoding (for WASM)
  //===------------------------------------------------------------------===//

  /**
   * Write an unsigned LEB128 encoded integer.
   */
  writeULEB128(value: i32): ByteBuffer {
    var v = value;
    while (true) {
      let byte = v & 0x7F;
      v = v >>> 7;
      if (v != 0) {
        this.writeByte(byte | 0x80);
      } else {
        this.writeByte(byte);
        return this;
      }
    }
  }

  /**
   * Write a signed LEB128 encoded integer.
   */
  writeSLEB128(value: i32): ByteBuffer {
    var v = value;
    var more = true;
    while (more) {
      let byte = v & 0x7F;
      v = v >> 7;
      // Check if more bytes needed
      if ((v == 0 && (byte & 0x40) == 0) || (v == -1 && (byte & 0x40) != 0)) {
        more = false;
        this.writeByte(byte);
      } else {
        this.writeByte(byte | 0x80);
      }
    }
    return this;
  }

  /**
   * Write a 64-bit unsigned LEB128.
   */
  writeULEB128_64(value: i64): ByteBuffer {
    var v = value;
    while (true) {
      let byte = (v & 0x7F) as i32;
      v = v >>> 7;
      if (v != 0) {
        this.writeByte(byte | 0x80);
      } else {
        this.writeByte(byte);
        return this;
      }
    }
  }

  /**
   * Write a 64-bit signed LEB128.
   */
  writeSLEB128_64(value: i64): ByteBuffer {
    var v = value;
    var more = true;
    while (more) {
      let byte = (v & 0x7F) as i32;
      v = v >> 7;
      if ((v == 0 && (byte & 0x40) == 0) || (v == -1 && (byte & 0x40) != 0)) {
        more = false;
        this.writeByte(byte);
      } else {
        this.writeByte(byte | 0x80);
      }
    }
    return this;
  }

  //===------------------------------------------------------------------===//
  // Random Access (for patching)
  //===------------------------------------------------------------------===//

  /**
   * Read a byte at an absolute position.
   */
  getByte(index: i32): i32 {
    let (chunkIndex, localOffset) = this.#resolveIndex(index);
    if (chunkIndex < this.#chunks.length) {
      return __byte_array_get(this.#chunks[chunkIndex], localOffset);
    }
    return __byte_array_get(this.#currentChunk, localOffset);
  }

  /**
   * Write a byte at an absolute position (for patching).
   */
  setByte(index: i32, value: i32): void {
    let (chunkIndex, localOffset) = this.#resolveIndex(index);
    if (chunkIndex < this.#chunks.length) {
      __byte_array_set(this.#chunks[chunkIndex], localOffset, value);
    } else {
      __byte_array_set(this.#currentChunk, localOffset, value);
    }
  }

  /**
   * Patch a U32 at an absolute position (little-endian).
   */
  patchU32(index: i32, value: i32): void {
    this.setByte(index, value & 0xFF);
    this.setByte(index + 1, (value >> 8) & 0xFF);
    this.setByte(index + 2, (value >> 16) & 0xFF);
    this.setByte(index + 3, (value >> 24) & 0xFF);
  }

  //===------------------------------------------------------------------===//
  // Output
  //===------------------------------------------------------------------===//

  /**
   * Convert to a single contiguous ByteArray.
   */
  toByteArray(): ByteArray {
    let totalLen = this.length;
    if (totalLen == 0) {
      return __byte_array_new(0);
    }

    let result = __byte_array_new(totalLen);
    var offset = 0;

    // Copy all full chunks
    var i = 0;
    while (i < this.#chunks.length) {
      let chunk = this.#chunks[i];
      let chunkLen = __byte_array_length(chunk);
      __byte_array_copy(result, offset, chunk, 0, chunkLen);
      offset = offset + chunkLen;
      i = i + 1;
    }

    // Copy current chunk
    if (this.#currentPos > 0) {
      __byte_array_copy(result, offset, this.#currentChunk, 0, this.#currentPos);
    }

    return result;
  }

  /**
   * Clear the buffer, reusing the first chunk.
   */
  clear(): void {
    this.#chunks = new Array<ByteArray>();
    this.#currentPos = 0;
    this.#totalLength = 0;
    // Keep #currentChunk for reuse
  }

  //===------------------------------------------------------------------===//
  // Internal Helpers
  //===------------------------------------------------------------------===//

  /**
   * Ensure at least 1 byte is available for writing.
   * Returns the number of bytes available in the current chunk.
   */
  #ensureSpace(needed: i32): i32 {
    let chunkLen = __byte_array_length(this.#currentChunk);
    if (this.#currentPos >= chunkLen) {
      // Rotate to new chunk
      this.#chunks.push(this.#currentChunk);
      this.#totalLength = this.#totalLength + chunkLen;

      // Double the chunk size, but at least fit `needed`
      var newCapacity = chunkLen * 2;
      if (newCapacity < needed) {
        newCapacity = needed;
      }
      this.#currentChunk = __byte_array_new(newCapacity);
      this.#currentPos = 0;
      return newCapacity;
    }
    return chunkLen - this.#currentPos;
  }

  /**
   * Resolve an absolute index to (chunkIndex, localOffset).
   */
  #resolveIndex(index: i32): (i32, i32) {
    var remaining = index;
    var chunkIdx = 0;
    while (chunkIdx < this.#chunks.length) {
      let chunkLen = __byte_array_length(this.#chunks[chunkIdx]);
      if (remaining < chunkLen) {
        return (chunkIdx, remaining);
      }
      remaining = remaining - chunkLen;
      chunkIdx = chunkIdx + 1;
    }
    // In current chunk
    return (chunkIdx, remaining);
  }
}
