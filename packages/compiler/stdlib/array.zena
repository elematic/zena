import { IndexOutOfBoundsError } from 'zena:error';

export interface Sequence<T> {
  length: i32 { get; }
  operator [](index: i32): T;
  map<U>(f: (item: T, index: i32, seq: Sequence<T>) => U): Sequence<U>;
}

export interface MutableSequence<T> extends Sequence<T> {
  operator []=(index: i32, value: T): void;
}

export final extension class ImmutableArray<T> on array<T> implements Sequence<T> {
  @intrinsic('array.len')
  declare length: i32;

  @intrinsic('array.get')
  declare operator [](index: i32): T;

  static from(seq: Sequence<T>): ImmutableArray<T> {
    let len = seq.length;
    let result = __array_new_empty<T>(len);
    var i = 0;
    while (i < len) {
      result[i] = seq[i];
      i = i + 1;
    }
    return result as ImmutableArray<T>;
  }

  map<U>(f: (item: T, index: i32, seq: Sequence<T>) => U): Sequence<U> {
    let len = this.length;
    let result = __array_new_empty<U>(len);
    var i = 0;
    while (i < len) {
      result[i] = f(this[i], i, this);
      i = i + 1;
    }
    return result as Sequence<U>;
  }
}

export final extension class FixedArray<T> on array<T> implements MutableSequence<T> {
  @intrinsic('array.len')
  declare length: i32;

  constructor(length: i32, value: T) {
    super(__array_new(length, value));
  }

  @intrinsic('array.get')
  declare operator [](index: i32): T;

  @intrinsic('array.set')
  declare operator []=(index: i32, value: T): void;

  static from(seq: Sequence<T>): FixedArray<T> {
    let len = seq.length;
    let result = __array_new_empty<T>(len);
    var i = 0;
    while (i < len) {
      result[i] = seq[i];
      i = i + 1;
    }
    return result;
  }

  map<U>(f: (item: T, index: i32, seq: Sequence<T>) => U): Sequence<U> {
    let len = this.length;
    let result = __array_new_empty<U>(len);
    var i = 0;
    while (i < len) {
      result[i] = f(this[i], i, this);
      i = i + 1;
    }
    return result as Sequence<U>;
  }

  reverse(): FixedArray<T> {
    let len = this.length;
    let result = __array_new_empty<T>(len);
    var i = 0;
    while (i < len) {
      result[i] = this[len - 1 - i];
      i = i + 1;
    }
    return result;
  }
}

export class Array<T> implements MutableSequence<T> {
  #buffer: FixedArray<T>;
  #length: i32 = 0;

  constructor(capacity: i32 = 8) {
    this.#buffer = __array_new_empty<T>(capacity);
  }

  static from(seq: Sequence<T>): Array<T> {
    let len = seq.length;
    let result = new Array<T>(len);
    var i = 0;
    while (i < len) {
      result.push(seq[i]);
      i = i + 1;
    }
    return result;
  }

  length: i32 {
    get {
      return this.#length;
    }
  }

  push(value: T): void {
    if (this.#length == this.#buffer.length) {
      this.#grow();
    }
    this.#buffer[this.#length] = value;
    this.#length = this.#length + 1;
  }

  pop(): T {
    this.#length = this.#length - 1;
    return this.#buffer[this.#length];
  }

  operator [](index: i32): T {
    if (index < 0 || index >= this.#length) {
      throw new IndexOutOfBoundsError(index, this.#length);
    }
    return this.#buffer[index];
  }

  operator []=(index: i32, value: T): void {
    if (index < 0 || index >= this.#length) {
      throw new IndexOutOfBoundsError(index, this.#length);
    }
    this.#buffer[index] = value;
  }

  map<U>(f: (item: T, index: i32, seq: Sequence<T>) => U): Sequence<U> {
    let len = this.#length;
    let result = new Array<U>(len);
    var i = 0;
    while (i < len) {
      result.push(f(this[i], i, this as Array<T>));
      i = i + 1;
    }
    return result;
  }

  #grow(): void {
    let newCapacity = this.#buffer.length * 2;
    let newBuffer = __array_new_empty<T>(newCapacity);
    var i = 0;
    while (i < this.#length) {
      newBuffer[i] = this.#buffer[i];
      i = i + 1;
    }
    this.#buffer = newBuffer;
  }
}
