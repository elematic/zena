/**
 * WIT Resolver
 *
 * Performs semantic validation on the parsed AST. Detects errors like:
 * - Duplicate definitions (types, interfaces, worlds)
 * - Undefined type references
 * - Cyclic type dependencies
 * - Invalid use statements
 * - Empty enums/variants
 * - Invalid borrow in return position
 * - Invalid map key types
 * - Feature gate violations (@since/@unstable)
 * - Cross-package reference validation
 *
 * Based on the canonical implementation in wasm-tools:
 * https://github.com/bytecodealliance/wasm-tools/blob/main/crates/wit-parser/src/ast/resolve.rs
 */

import {String} from 'zena:string';
import {StringBuilder} from 'zena:string-builder';
import {Map} from 'zena:map';
import {Span} from './token.zena';
import {
  Ast, AstItem, AstItemTag, InterfaceDef, WorldDef, TypeDef, TypeDefTag,
  InterfaceItem, InterfaceItemTag, WorldItem, WorldItemTag, Use, UsePath, UsePathTag,
  Type, TypeTag, Field, Case, EnumCaseDef, FlagDef, NamedFunc, Func, Param,
  ResourceFunc, ResourceFuncTag, Id, PackageName, ToplevelUse, NestedPackage,
  Export, Import, ExternKind, ExternKindTag, Include, IncludeName, UseName,
  Docs, Attribute, AttributeTag
} from './parser.zena';

// ============================================================================
// Resolution Error
// ============================================================================

/**
 * Error produced during resolution/semantic validation.
 */
export class ResolveError extends Error {
  span: Span;

  #new(message: String, span: Span) {
    super(message);
    this.span = span;
  }
}

// ============================================================================
// Symbol Table Entry
// ============================================================================

/** Tag for symbol kinds. */
export enum SymbolKind {
  Type,
  Resource,
  Interface,
  World,
  Func,
}

/** An entry in the symbol table. */
export class SymbolEntry {
  name: String;
  kind: SymbolKind;
  span: Span;
  /** Whether this symbol is feature-gated (has @unstable annotation). */
  isGated: boolean;
  /** The source of this symbol (e.g., world name for include tracking). */
  source: String | null;

  #new(name: String, kind: SymbolKind, span: Span) {
    this.name = name;
    this.kind = kind;
    this.span = span;
    this.isGated = false;
    this.source = null;
  }

  static gated(name: String, kind: SymbolKind, span: Span): SymbolEntry {
    let s = new SymbolEntry(name, kind, span);
    s.isGated = true;
    return s;
  }

  static withSource(name: String, kind: SymbolKind, span: Span, source: String): SymbolEntry {
    let s = new SymbolEntry(name, kind, span);
    s.source = source;
    return s;
  }
}

// ============================================================================
// Package Registry
// ============================================================================

/** Convert a PackageName to a lookup key (namespace:name@version if version present). */
let packageNameToKey = (name: PackageName): String => {
  var key = name.namespace.name + ":" + name.name.name;
  if (name.version != null) {
    key = key + "@" + (name.version as String);
  }
  return key;
};

/**
 * Contents of a package - its interfaces and worlds.
 */
class PackageContent {
  /** Interfaces defined in this package, keyed by name. */
  interfaces: Map<String, InterfaceDef>;
  /** Worlds defined in this package, keyed by name. */
  worlds: Map<String, WorldDef>;
  /** The package name for error messages. */
  name: PackageName;

  #new(name: PackageName) {
    this.interfaces = new Map<String, InterfaceDef>();
    this.worlds = new Map<String, WorldDef>();
    this.name = name;
  }
}

/**
 * Registry of all packages in the AST, for cross-package reference resolution.
 */
class PackageRegistry {
  /** Map from package key (namespace:name) to package content. */
  #packages: Map<String, PackageContent>;
  /** List of all package keys for error messages. */
  #knownPackages: Array<String>;

  #new() {
    this.#packages = new Map<String, PackageContent>();
    this.#knownPackages = new Array<String>();
  }

  /** Build a registry from an AST. */
  static build(ast: Ast): PackageRegistry {
    let registry = new PackageRegistry();

    // Register main package
    if (ast.packageName != null) {
      let name = ast.packageName as PackageName;
      registry.#registerPackage(name, ast.items);
    }

    // Register nested packages
    var i = 0;
    while (i < ast.nestedPackages.length) {
      let pkg = ast.nestedPackages[i];
      registry.#registerPackage(pkg.name, pkg.items);
      i = i + 1;
    }

    return registry;
  }

  /** Register a package with its items. */
  #registerPackage(name: PackageName, items: Array<AstItem>): void {
    let key = packageNameToKey(name);

    // Check for duplicate package
    if (this.#packages.has(key)) {
      // Later we can make this an error, for now just merge
    }

    let content = new PackageContent(name);

    // Collect interfaces and worlds
    var i = 0;
    while (i < items.length) {
      let item = items[i];
      if (item.tag == AstItemTag.Interface) {
        let iface = item.interfaceDef as InterfaceDef;
        content.interfaces.set(iface.name.name, iface);
      } else if (item.tag == AstItemTag.World) {
        let world = item.worldDef as WorldDef;
        content.worlds.set(world.name.name, world);
      }
      i = i + 1;
    }

    this.#packages.set(key, content);
    this.#knownPackages.push(key);
  }

  /** Look up a package by full key (including version if present). */
  getPackageByName(pkgName: PackageName): PackageContent | null {
    let key = packageNameToKey(pkgName);
    let (content, found) = this.#packages.get(key);
    if (found) {
      return content;
    }
    return null;
  }

  /** Look up a package by namespace:name (legacy, without version). */
  getPackage(namespace: String, name: String): PackageContent | null {
    let key = namespace + ":" + name;
    let (content, found) = this.#packages.get(key);
    if (found) {
      return content;
    }
    return null;
  }

  /** Look up an interface by PackageName and interface name. */
  getInterfaceByPkg(pkgName: PackageName, ifaceName: String): InterfaceDef | null {
    let pkg = this.getPackageByName(pkgName);
    if (pkg == null) {
      return null;
    }
    let p = pkg as PackageContent;
    let (iface, found) = p.interfaces.get(ifaceName);
    if (found) {
      return iface;
    }
    return null;
  }

  /** Look up an interface by full path (namespace:name/interface). Legacy without version. */
  getInterface(namespace: String, pkgName: String, ifaceName: String): InterfaceDef | null {
    let pkg = this.getPackage(namespace, pkgName);
    if (pkg == null) {
      return null;
    }
    let p = pkg as PackageContent;
    let (iface, found) = p.interfaces.get(ifaceName);
    if (found) {
      return iface;
    }
    return null;
  }

  /** Look up a world by PackageName and world name. */
  getWorldByPkg(pkgName: PackageName, worldName: String): WorldDef | null {
    let pkg = this.getPackageByName(pkgName);
    if (pkg == null) {
      return null;
    }
    let p = pkg as PackageContent;
    let (world, found) = p.worlds.get(worldName);
    if (found) {
      return world;
    }
    return null;
  }

  /** Look up a world by full path (namespace:name/world). Legacy without version. */
  getWorld(namespace: String, pkgName: String, worldName: String): WorldDef | null {
    let pkg = this.getPackage(namespace, pkgName);
    if (pkg == null) {
      return null;
    }
    let p = pkg as PackageContent;
    let (world, found) = p.worlds.get(worldName);
    if (found) {
      return world;
    }
    return null;
  }

  /** Check if a package exists by PackageName (with version). */
  hasPackageByName(pkgName: PackageName): boolean {
    let key = packageNameToKey(pkgName);
    return this.#packages.has(key);
  }

  /** Check if a package exists (legacy, without version). */
  hasPackage(namespace: String, name: String): boolean {
    let key = namespace + ":" + name;
    return this.#packages.has(key);
  }

  /** Get list of known package names for error messages. */
  getKnownPackages(): Array<String> {
    return this.#knownPackages;
  }
}

// ============================================================================
// Helper Functions
// ============================================================================

/** Convert a string to lowercase (simple ASCII version). */
let toLower = (s: String): String => {
  let sb = new StringBuilder(s.length);
  var i = 0;
  while (i < s.length) {
    let b = s.getByteAt(i);
    // A-Z (65-90) -> a-z (97-122)
    if (b >= 65 && b <= 90) {
      sb.appendByte(b + 32);
    } else {
      sb.appendByte(b);
    }
    i = i + 1;
  }
  return sb.toString();
};

/** Find a symbol in a list by name (case-insensitive). */
let findSymbolInList = (symbols: Array<SymbolEntry>, name: String): SymbolEntry | null => {
  let lower = toLower(name);
  var i = 0;
  while (i < symbols.length) {
    let sym = symbols[i];
    if (toLower(sym.name) == lower) {
      return sym;
    }
    i = i + 1;
  }
  return null;
};

/** Check if a type is a valid map key type. */
let isValidMapKeyType = (t: Type): boolean => {
  return t.tag == TypeTag.Bool ||
         t.tag == TypeTag.U8 || t.tag == TypeTag.U16 ||
         t.tag == TypeTag.U32 || t.tag == TypeTag.U64 ||
         t.tag == TypeTag.S8 || t.tag == TypeTag.S16 ||
         t.tag == TypeTag.S32 || t.tag == TypeTag.S64 ||
         t.tag == TypeTag.Char || t.tag == TypeTag.String;
};

/** Strip the explicit identifier prefix (%) if present. */
let stripExplicitPrefix = (s: String): String => {
  if (s.length > 0 && s.getByteAt(0) == 37) {  // '%' = 37
    return s.sliceBytes(1, s.length);
  }
  return s;
};

/** Check if a Docs has an @unstable attribute (feature gated). */
let isGated = (docs: Docs): boolean => {
  if (docs.attributes == null) {
    return false;
  }
  let attrs = docs.attributes as Array<Attribute>;
  var i = 0;
  while (i < attrs.length) {
    if (attrs[i].tag == AttributeTag.Unstable) {
      return true;
    }
    i = i + 1;
  }
  return false;
};

/** Get the full path string from a UsePath. */
let getFullPath = (path: UsePath): String => {
  if (path.tag == UsePathTag.Id) {
    return (path.id as Id).name;
  }
  // Package style: namespace:name/interface
  let pkg = path.packageId as PackageName;
  let name = (path.name as Id).name;
  return pkg.namespace.name + ":" + pkg.name.name + "/" + name;
};

// ============================================================================
// Scope
// ============================================================================

/**
 * A scope for name resolution. Contains symbols defined at this level.
 */
class Scope {
  symbols: Array<SymbolEntry>;
  /** Types defined in this scope (for cycle detection). */
  types: Array<TypeDef>;
  /** Worlds defined in this scope (for include cycle detection). */
  worlds: Array<WorldDef>;
  /** Interfaces defined in this scope (for use validation). */
  interfaces: Array<InterfaceDef>;

  #new() {
    this.symbols = new Array<SymbolEntry>();
    this.types = new Array<TypeDef>();
    this.worlds = new Array<WorldDef>();
    this.interfaces = new Array<InterfaceDef>();
  }

  /** Find a symbol by name (case-insensitive for kebab-case). */
  find(name: String): SymbolEntry | null {
    let lower = toLower(name);
    var i = 0;
    while (i < this.symbols.length) {
      let sym = this.symbols[i];
      if (toLower(sym.name) == lower) {
        return sym;
      }
      i = i + 1;
    }
    return null;
  }

  /** Add a symbol, returning error if duplicate. */
  add(name: String, kind: SymbolKind, span: Span, gated: boolean): ResolveError | null {
    let existing = this.find(name);
    if (existing != null) {
      let e = existing as SymbolEntry;
      // Case-insensitive check for kebab-case identifiers
      if (toLower(name) == toLower(e.name) && !(name == e.name)) {
        return new ResolveError(
          "name `" + name + "` conflicts with `" + e.name + "` (kebab-case identifiers are case-insensitive)",
          span
        );
      }
      return new ResolveError("name `" + name + "` is defined more than once", span);
    }
    let sym = if (gated) SymbolEntry.gated(name, kind, span) else new SymbolEntry(name, kind, span);
    this.symbols.push(sym);
    return null;
  }

  /** Find a type by name. */
  findType(name: String): TypeDef | null {
    var i = 0;
    while (i < this.types.length) {
      let td = this.types[i];
      if (td.name.name == name) {
        return td;
      }
      i = i + 1;
    }
    return null;
  }

  /** Find a world by name. */
  findWorld(name: String): WorldDef | null {
    var i = 0;
    while (i < this.worlds.length) {
      let wd = this.worlds[i];
      if (wd.name.name == name) {
        return wd;
      }
      i = i + 1;
    }
    return null;
  }

  /** Find an interface by name. */
  findInterface(name: String): InterfaceDef | null {
    var i = 0;
    while (i < this.interfaces.length) {
      let iface = this.interfaces[i];
      if (iface.name.name == name) {
        return iface;
      }
      i = i + 1;
    }
    return null;
  }
}

// ============================================================================
// Resolver
// ============================================================================

/**
 * Resolves an AST, performing semantic validation.
 */
export class Resolver {
  /** Stack of scopes for nested name resolution. */
  #scopes: Array<Scope>;
  /** Current package name (for error messages). */
  #packageName: PackageName | null;
  /** Types being resolved (for cycle detection). */
  #resolving: Array<String>;
  /** Interfaces being resolved (for use cycle detection). */
  #resolvingInterfaces: Array<String>;
  /** Worlds being included (for include cycle detection). */
  #includingWorlds: Array<String>;
  /** Whether we're currently inside a gated context (@unstable). */
  #inGatedContext: boolean;
  /** Registry of all packages for cross-package resolution. */
  #registry: PackageRegistry | null;

  #new() {
    this.#scopes = new Array<Scope>();
    this.#packageName = null;
    this.#resolving = new Array<String>();
    this.#resolvingInterfaces = new Array<String>();
    this.#includingWorlds = new Array<String>();
    this.#inGatedContext = false;
    this.#registry = null;
  }

  /**
   * Resolve an AST. Throws ResolveError on validation failure.
   */
  static resolve(ast: Ast): void {
    let resolver = new Resolver();
    // Build registry of all packages first
    resolver.#registry = PackageRegistry.build(ast);
    resolver.#resolveAst(ast);
  }

  // --------------------------------------------------------------------------
  // Scope Management
  // --------------------------------------------------------------------------

  #pushScope(): void {
    this.#scopes.push(new Scope());
  }

  #popScope(): void {
    if (this.#scopes.length > 0) {
      this.#scopes.pop();
    }
  }

  #currentScope(): Scope {
    if (this.#scopes.length == 0) {
      // Create a root scope if none exists
      this.#pushScope();
    }
    return this.#scopes[this.#scopes.length - 1];
  }

  /** Find a symbol in any scope (innermost first). */
  #findSymbol(name: String): SymbolEntry | null {
    var i = this.#scopes.length - 1;
    while (i >= 0) {
      let sym = this.#scopes[i].find(name);
      if (sym != null) {
        return sym;
      }
      i = i - 1;
    }
    return null;
  }

  /** Define a symbol in current scope. */
  #define(name: String, kind: SymbolKind, span: Span): void {
    this.#defineWithGating(name, kind, span, false);
  }

  /** Define a symbol in current scope with explicit gating. */
  #defineWithGating(name: String, kind: SymbolKind, span: Span, gated: boolean): void {
    let err = this.#currentScope().add(name, kind, span, gated);
    if (err != null) {
      throw err as ResolveError;
    }
  }

  /** Check if referencing a gated symbol from non-gated context. */
  #checkGatedReference(sym: SymbolEntry, refSpan: Span, itemKind: String): void {
    if (sym.isGated && !this.#inGatedContext) {
      throw new ResolveError(
        "found a reference to a " + itemKind + " which is excluded due to its feature not being activated",
        refSpan
      );
    }
  }

  // --------------------------------------------------------------------------
  // AST Resolution
  // --------------------------------------------------------------------------

  #resolveAst(ast: Ast): void {
    // Check that a package declaration exists:
    // - Empty files need a package declaration (no items, no nested packages)
    // - Files with top-level items need a package declaration
    // - Files with only nested packages don't need a top-level package declaration
    if (ast.packageName == null && (ast.nestedPackages.length == 0 || ast.items.length > 0)) {
      throw new ResolveError(
        "no `package` header was found in any WIT file for this package",
        new Span(0, 0)
      );
    }

    this.#packageName = ast.packageName;
    this.#pushScope();

    // First pass: collect interfaces and worlds (they take priority over use aliases)
    var i = 0;
    while (i < ast.items.length) {
      let item = ast.items[i];
      if (item.tag == AstItemTag.Interface) {
        let iface = item.interfaceDef as InterfaceDef;
        let gated = isGated(iface.docs);
        this.#defineWithGating(iface.name.name, SymbolKind.Interface, iface.name.span, gated);
        // Store interface definition for use validation
        this.#currentScope().interfaces.push(iface);
      } else if (item.tag == AstItemTag.World) {
        let world = item.worldDef as WorldDef;
        let gated = isGated(world.docs);
        this.#defineWithGating(world.name.name, SymbolKind.World, world.name.span, gated);
        // Store the world definition for include cycle detection
        this.#currentScope().worlds.push(world);
      }
      i = i + 1;
    }

    // Second mini-pass: collect top-level use aliases
    // Check for conflicts where a use alias appears BEFORE an interface/world in source order
    // but only if they're in the same "file" (no package declaration between them)
    let packageDeclPos = if (ast.packageName != null) (ast.packageName as PackageName).span.start else 0;
    i = 0;
    while (i < ast.items.length) {
      let item = ast.items[i];
      if (item.tag == AstItemTag.Use) {
        let use = item.use as ToplevelUse;
        let name = if (use.asName != null) (use.asName as Id).name else use.item.getName().name;
        let span = if (use.asName != null) (use.asName as Id).span else use.item.getName().span;
        let existing = this.#findSymbol(name);
        if (existing != null) {
          // Name already defined. Check if this use alias came BEFORE the definition.
          let e = existing as SymbolEntry;
          if (span.start < e.span.start) {
            // Use alias defined first, interface/world defined after.
            // But if the package declaration is BETWEEN them, they're in different files.
            let useBeforePkg = span.start < packageDeclPos;
            let defAfterPkg = e.span.start > packageDeclPos;
            if (useBeforePkg && defAfterPkg) {
              // Different files - silently shadow the use alias
            } else {
              // Same file - error
              throw new ResolveError(
                "duplicate name `" + name + "` in this file",
                e.span
              );
            }
          }
          // Otherwise, use alias is after the definition - silently shadow
        } else {
          this.#define(name, SymbolKind.Interface, span);
        }
      }
      i = i + 1;
    }

    // Second pass: resolve each item
    i = 0;
    while (i < ast.items.length) {
      let item = ast.items[i];
      this.#resolveAstItem(item);
      i = i + 1;
    }

    // Check for duplicate nested package names
    this.#checkDuplicateNestedPackages(ast.nestedPackages);

    // Resolve nested packages - each gets its own scope
    i = 0;
    while (i < ast.nestedPackages.length) {
      let pkg = ast.nestedPackages[i];
      this.#resolveNestedPackage(pkg);
      i = i + 1;
    }

    this.#popScope();
  }

  /** Check for duplicate nested package names. */
  #checkDuplicateNestedPackages(packages: Array<NestedPackage>): void {
    var i = 0;
    while (i < packages.length) {
      let pkg1 = packages[i];
      let name1 = this.#packageNameToString(pkg1.name);
      var j = i + 1;
      while (j < packages.length) {
        let pkg2 = packages[j];
        let name2 = this.#packageNameToString(pkg2.name);
        if (name1 == name2) {
          throw new ResolveError(
            "package " + name1 + " is defined in two different locations",
            pkg2.name.span
          );
        }
        j = j + 1;
      }
      i = i + 1;
    }
  }

  /** Convert a PackageName to a string for comparison. */
  #packageNameToString(pkg: PackageName): String {
    let base = pkg.namespace.name + ":" + pkg.name.name;
    if (pkg.version != null) {
      return base + "@" + (pkg.version as String);
    }
    return base;
  }

  #resolveAstItem(item: AstItem): void {
    if (item.tag == AstItemTag.Interface) {
      this.#resolveInterface(item.interfaceDef as InterfaceDef);
    } else if (item.tag == AstItemTag.World) {
      this.#resolveWorld(item.worldDef as WorldDef);
    } else if (item.tag == AstItemTag.Use) {
      this.#resolveToplevelUse(item.use as ToplevelUse);
    }
  }

  // --------------------------------------------------------------------------
  // Nested Package Resolution
  // --------------------------------------------------------------------------

  #resolveNestedPackage(pkg: NestedPackage): void {
    // Each nested package gets its own scope
    this.#pushScope();

    // First pass: collect all names in this package (interfaces, worlds, and top-level use aliases)
    var i = 0;
    while (i < pkg.items.length) {
      let item = pkg.items[i];
      if (item.tag == AstItemTag.Interface) {
        let iface = item.interfaceDef as InterfaceDef;
        this.#define(iface.name.name, SymbolKind.Interface, iface.name.span);
        // Store interface definition for use validation
        this.#currentScope().interfaces.push(iface);
      } else if (item.tag == AstItemTag.World) {
        let world = item.worldDef as WorldDef;
        this.#define(world.name.name, SymbolKind.World, world.name.span);
        // Store world definition for include resolution (needed for #findWorldDef)
        this.#currentScope().worlds.push(world);
      } else if (item.tag == AstItemTag.Use) {
        // Top-level use creates an alias - handle like in resolve()
        let use = item.use as ToplevelUse;
        let name = if (use.asName != null) (use.asName as Id).name else use.item.getName().name;
        let span = if (use.asName != null) (use.asName as Id).span else use.item.getName().span;
        let existing = this.#findSymbol(name);
        if (existing == null) {
          this.#define(name, SymbolKind.Interface, span);
        }
        // else: silently shadow - will resolve in second pass
      }
      i = i + 1;
    }

    // Second pass: resolve each item
    i = 0;
    while (i < pkg.items.length) {
      this.#resolveAstItem(pkg.items[i]);
      i = i + 1;
    }

    this.#popScope();
  }

  // --------------------------------------------------------------------------
  // Interface Resolution
  // --------------------------------------------------------------------------

  #resolveInterface(iface: InterfaceDef): void {
    let ifaceGated = isGated(iface.docs);
    let prevGatedContext = this.#inGatedContext;

    // Track this interface for use cycle detection
    this.#resolvingInterfaces.push(iface.name.name);

    // If interface is gated, we're now in a gated context
    if (ifaceGated) {
      this.#inGatedContext = true;
    }

    this.#pushScope();

    // First pass: collect all type names and functions with gating info
    var i = 0;
    while (i < iface.items.length) {
      let item = iface.items[i];
      if (item.tag == InterfaceItemTag.TypeDef) {
        let td = item.typeDef as TypeDef;
        let itemGated = isGated(td.docs);
        // Resources get their own symbol kind
        let kind = if (td.tag == TypeDefTag.Resource) SymbolKind.Resource else SymbolKind.Type;

        // If interface is gated, items must also be gated (bad-gate3)
        if (ifaceGated && !itemGated) {
          throw new ResolveError(
            "this type is not gated by a feature but its interface is gated by a feature: found a reference to a interface which is excluded due to its feature not being activated",
            td.name.span
          );
        }

        this.#defineWithGating(td.name.name, kind, td.name.span, itemGated);
        this.#currentScope().types.push(td);
      } else if (item.tag == InterfaceItemTag.Func) {
        let f = item.func as NamedFunc;
        let itemGated = isGated(f.docs);
        this.#defineWithGating(f.name.name, SymbolKind.Func, f.name.span, itemGated);
      }
      i = i + 1;
    }

    // Second pass: resolve types and validate
    i = 0;
    while (i < iface.items.length) {
      let item = iface.items[i];
      this.#resolveInterfaceItem(item);
      i = i + 1;
    }

    this.#popScope();
    this.#inGatedContext = prevGatedContext;
    this.#resolvingInterfaces.pop();
  }

  #resolveInterfaceItem(item: InterfaceItem): void {
    if (item.tag == InterfaceItemTag.TypeDef) {
      let td = item.typeDef as TypeDef;
      // Set gated context for resolving this type
      let prevGatedContext = this.#inGatedContext;
      if (isGated(td.docs)) {
        this.#inGatedContext = true;
      }
      this.#resolveTypeDef(td);
      this.#inGatedContext = prevGatedContext;
    } else if (item.tag == InterfaceItemTag.Func) {
      let f = item.func as NamedFunc;
      // Set gated context for resolving this function
      let prevGatedContext = this.#inGatedContext;
      if (isGated(f.docs)) {
        this.#inGatedContext = true;
      }
      this.#resolveNamedFunc(f);
      this.#inGatedContext = prevGatedContext;
    } else if (item.tag == InterfaceItemTag.Use) {
      this.#resolveUse(item.use as Use);
    }
  }

  // --------------------------------------------------------------------------
  // World Resolution
  // --------------------------------------------------------------------------

  #resolveWorld(world: WorldDef): void {
    // Track this world for include cycle detection
    this.#includingWorlds.push(world.name.name);

    this.#pushScope();

    // Track import/export names separately for conflict detection
    let imports = new Array<SymbolEntry>();
    let exports = new Array<SymbolEntry>();

    // First pass: collect names from type definitions
    var i = 0;
    while (i < world.items.length) {
      let item = world.items[i];
      if (item.tag == WorldItemTag.TypeDef) {
        let td = item.typeDef as TypeDef;
        this.#define(td.name.name, SymbolKind.Type, td.name.span);
        this.#currentScope().types.push(td);
      }
      i = i + 1;
    }

    // Second pass: resolve items and check import/export conflicts
    i = 0;
    while (i < world.items.length) {
      let item = world.items[i];
      this.#resolveWorldItem(item, imports, exports, world.name.name);
      i = i + 1;
    }

    this.#popScope();
    this.#includingWorlds.pop();
  }

  #resolveWorldItem(item: WorldItem, imports: Array<SymbolEntry>, exports: Array<SymbolEntry>, worldName: String): void {
    if (item.tag == WorldItemTag.Import) {
      let imp = item.importItem as Import;
      // Set gated context based on the import's docs
      let prevGatedContext = this.#inGatedContext;
      if (isGated(imp.docs)) {
        this.#inGatedContext = true;
      }
      this.#resolveExternKind(imp.kind, true, imports, worldName);
      this.#inGatedContext = prevGatedContext;
    } else if (item.tag == WorldItemTag.Export) {
      let exp = item.exportItem as Export;
      // Set gated context based on the export's docs
      let prevGatedContext = this.#inGatedContext;
      if (isGated(exp.docs)) {
        this.#inGatedContext = true;
      }
      this.#resolveExternKind(exp.kind, false, exports, worldName);
      this.#inGatedContext = prevGatedContext;
    } else if (item.tag == WorldItemTag.Use) {
      this.#resolveUse(item.use as Use);
    } else if (item.tag == WorldItemTag.TypeDef) {
      let td = item.typeDef as TypeDef;
      let prevGatedContext = this.#inGatedContext;
      if (isGated(td.docs)) {
        this.#inGatedContext = true;
      }
      this.#resolveTypeDef(td);
      this.#inGatedContext = prevGatedContext;
    } else if (item.tag == WorldItemTag.Include) {
      let inc = item.include as Include;
      // Set gated context based on the include's docs
      let prevGatedContext = this.#inGatedContext;
      if (isGated(inc.docs)) {
        this.#inGatedContext = true;
      }
      // Check include for shadowing before resolving
      this.#checkIncludeShadowing(inc, imports, exports);
      this.#resolveInclude(inc);
      this.#inGatedContext = prevGatedContext;
    }
  }

  /** Check if an include statement would shadow existing imports/exports. */
  #checkIncludeShadowing(include: Include, imports: Array<SymbolEntry>, exports: Array<SymbolEntry>): void {
    // Only check for local world references
    if (include.from.tag != UsePathTag.Id) {
      return;
    }
    let id = include.from.id as Id;
    let worldDef = this.#findWorldDef(id.name);
    if (worldDef == null) {
      return;
    }
    let w = worldDef as WorldDef;
    let worldName = id.name;

    // Check each item in the included world
    var i = 0;
    while (i < w.items.length) {
      let item = w.items[i];
      if (item.tag == WorldItemTag.Import) {
        let imp = item.importItem as Import;
        // Skip gated imports - they don't really exist in the active feature set
        if (isGated(imp.docs)) {
          i = i + 1;
          continue;
        }
        let impName = this.#getExternKindName(imp.kind);
        if (impName != null) {
          let name = impName as String;
          // Apply rename if exists
          let finalName = this.#applyIncludeRename(name, include.names);
          // Check if this would shadow an existing NON-GATED import
          let existing = findSymbolInList(imports, finalName);
          if (existing != null) {
            let e = existing as SymbolEntry;
            // Only error if the existing item is NOT gated AND from a different source
            // Duplicate includes of the same world are allowed (deduped)
            if (!e.isGated) {
              if (e.source != null && (e.source as String) == worldName) {
                // Same source - this is a duplicate include, skip without error
                i = i + 1;
                continue;
              }
              throw new ResolveError(
                "import of `" + finalName + "` shadows previously imported items",
                id.span
              );
            }
          }
          // Add to imports for future shadowing checks, with source tracking
          imports.push(SymbolEntry.withSource(finalName, SymbolKind.Func, id.span, worldName));
        }
      } else if (item.tag == WorldItemTag.Export) {
        let exp = item.exportItem as Export;
        // Skip gated exports
        if (isGated(exp.docs)) {
          i = i + 1;
          continue;
        }
        let expName = this.#getExternKindName(exp.kind);
        if (expName != null) {
          let name = expName as String;
          let finalName = this.#applyIncludeRename(name, include.names);
          let existing = findSymbolInList(exports, finalName);
          if (existing != null) {
            let e = existing as SymbolEntry;
            if (!e.isGated) {
              if (e.source != null && (e.source as String) == worldName) {
                // Same source - duplicate include, skip without error
                i = i + 1;
                continue;
              }
              throw new ResolveError(
                "export of `" + finalName + "` shadows previously exported items",
                id.span
              );
            }
          }
          exports.push(SymbolEntry.withSource(finalName, SymbolKind.Func, id.span, worldName));
        }
      }
      i = i + 1;
    }
  }

  /** Get the name from an extern kind, if applicable. */
  #getExternKindName(kind: ExternKind): String | null {
    if (kind.tag == ExternKindTag.Func) {
      return (kind.name as Id).name;
    }
    if (kind.tag == ExternKindTag.Interface) {
      return (kind.name as Id).name;
    }
    if (kind.tag == ExternKindTag.Path) {
      return (kind.path as UsePath).getName().name;
    }
    return null;
  }

  /** Apply a rename from include names if the name matches. */
  #applyIncludeRename(name: String, names: Array<IncludeName>): String {
    var i = 0;
    while (i < names.length) {
      let n = names[i];
      if (n.name.name == name) {
        return n.asName.name;
      }
      i = i + 1;
    }
    return name;
  }

  #resolveExternKind(kind: ExternKind, isImport: boolean, symbols: Array<SymbolEntry>, worldName: String): void {
    if (kind.tag == ExternKindTag.Func) {
      let funcName = kind.name as Id;
      // Check for duplicates in this category (imports or exports)
      let existing = findSymbolInList(symbols, funcName.name);
      if (existing != null) {
        let e = existing as SymbolEntry;
        // Skip conflict check if both are gated
        if (!(e.isGated && this.#inGatedContext)) {
          let direction = if (isImport) "import" else "export";
          throw new ResolveError(
            direction + " `" + funcName.name + "` conflicts with prior func of same name",
            funcName.span
          );
        }
      }
      // Check for conflicts with type definitions in the world
      let typeSym = this.#findSymbol(funcName.name);
      if (typeSym != null) {
        let ts = typeSym as SymbolEntry;
        if (ts.kind == SymbolKind.Type) {
          let direction = if (isImport) "import" else "export";
          throw new ResolveError(
            direction + " `" + funcName.name + "` conflicts with prior type of same name",
            funcName.span
          );
        }
      }
      // Mark as gated if in gated context
      if (this.#inGatedContext) {
        symbols.push(SymbolEntry.gated(funcName.name, SymbolKind.Func, funcName.span));
      } else {
        symbols.push(new SymbolEntry(funcName.name, SymbolKind.Func, funcName.span));
      }
      // Resolve the function type
      this.#resolveFunc(kind.funcDef as Func);
    } else if (kind.tag == ExternKindTag.Interface) {
      let ifaceName = kind.name as Id;
      // Check for duplicates
      let existing = findSymbolInList(symbols, ifaceName.name);
      if (existing != null) {
        let e = existing as SymbolEntry;
        // Skip conflict check if both are gated
        if (!(e.isGated && this.#inGatedContext)) {
          let direction = if (isImport) "import" else "export";
          throw new ResolveError(
            direction + " `" + ifaceName.name + "` conflicts with prior interface of same name",
            ifaceName.span
          );
        }
      }
      // Mark as gated if in gated context
      if (this.#inGatedContext) {
        symbols.push(SymbolEntry.gated(ifaceName.name, SymbolKind.Interface, ifaceName.span));
      } else {
        symbols.push(new SymbolEntry(ifaceName.name, SymbolKind.Interface, ifaceName.span));
      }
      // Resolve interface items in their own scope (inline interfaces have their own namespace)
      this.#pushScope();
      let items = kind.items as Array<InterfaceItem>;
      var j = 0;
      while (j < items.length) {
        this.#resolveInterfaceItem(items[j]);
        j = j + 1;
      }
      this.#popScope();
    } else if (kind.tag == ExternKindTag.Path) {
      let path = kind.path as UsePath;
      // For path imports, use the full path as the unique identifier
      let fullPath = getFullPath(path);
      let pathName = path.getName();
      // Check for duplicates using the full path
      let existing = findSymbolInList(symbols, fullPath);
      if (existing != null) {
        let e = existing as SymbolEntry;
        // Skip conflict check if both are gated
        if (!(e.isGated && this.#inGatedContext)) {
          let direction = if (isImport) "import" else "export";
          throw new ResolveError(
            direction + " `" + fullPath + "` conflicts with prior " + direction + " of same name",
            pathName.span
          );
        }
      }
      // Mark as gated if in gated context
      if (this.#inGatedContext) {
        symbols.push(SymbolEntry.gated(fullPath, SymbolKind.Interface, pathName.span));
        // Skip validation for gated items (the target may not exist or may be a world)
      } else {
        symbols.push(new SymbolEntry(fullPath, SymbolKind.Interface, pathName.span));
        // Validate path references exist (use statements reference interfaces)
        this.#resolveUsePath(path, false);
        // Validate path references an interface, not a world (invalid-world-import)
        this.#validatePathIsInterface(path, isImport);
      }
    }
  }

  /** Validate that a UsePath references an interface, not a world. */
  #validatePathIsInterface(path: UsePath, isImport: boolean): void {
    if (path.tag == UsePathTag.Id) {
      let id = path.id as Id;
      let sym = this.#findSymbol(id.name);
      if (sym != null) {
        let s = sym as SymbolEntry;
        if (s.kind == SymbolKind.World) {
          let direction = if (isImport) "import" else "export";
          throw new ResolveError(
            "cannot " + direction + " world `" + id.name + "` into a world",
            id.span
          );
        }
      }
    }
    // Package paths are validated at link time
  }

  // --------------------------------------------------------------------------
  // Type Definition Resolution
  // --------------------------------------------------------------------------

  #resolveTypeDef(td: TypeDef): void {
    // Check for empty enum
    if (td.tag == TypeDefTag.Enum) {
      let cases = td.enumCases as Array<EnumCaseDef>;
      if (cases.length == 0) {
        throw new ResolveError("empty enum", td.name.span);
      }
      // Check for duplicate case names
      this.#checkDuplicateCaseNames(cases);
    }

    // Check for empty variant
    if (td.tag == TypeDefTag.Variant) {
      let cases = td.cases as Array<Case>;
      if (cases.length == 0) {
        throw new ResolveError("empty variant", td.name.span);
      }
      // Check for duplicate case names
      this.#checkDuplicateVariantCases(cases);
      // Resolve case types
      var i = 0;
      while (i < cases.length) {
        let c = cases[i];
        if (c.type != null) {
          this.#resolveType(c.type as Type, false);
        }
        i = i + 1;
      }
    }

    // Resolve alias type
    if (td.tag == TypeDefTag.Alias) {
      let aliasType = td.aliasType as Type;
      // Check for cycles
      this.#resolving.push(td.name.name);
      this.#resolveType(aliasType, false);
      this.#resolving.pop();
    }

    // Resolve record fields
    if (td.tag == TypeDefTag.Record) {
      let fields = td.fields as Array<Field>;
      this.#checkDuplicateFieldNames(fields, td.name.span);
      var i = 0;
      while (i < fields.length) {
        this.#resolveType(fields[i].type, false);
        i = i + 1;
      }
    }

    // Resolve resource methods
    if (td.tag == TypeDefTag.Resource) {
      let funcs = td.resourceFuncs as Array<ResourceFunc>;
      // Check for duplicate constructors and method names
      this.#checkDuplicateResourceFuncs(funcs);

      // If the resource is gated, check that non-gated members are invalid
      // because they implicitly reference the gated resource type (bad-gate4, bad-gate5)
      let resourceGated = isGated(td.docs);

      var i = 0;
      while (i < funcs.length) {
        let rf = funcs[i];
        let funcGated = isGated(rf.func.docs);

        // If resource is gated and method is not, it's an error
        if (resourceGated && !funcGated) {
          throw new ResolveError(
            "found a reference to a type which is excluded due to its feature not being activated",
            rf.func.name.span
          );
        }

        // Validate constructor return type
        if (rf.tag == ResourceFuncTag.Constructor) {
          this.#validateConstructorReturn(rf.func, td.name.name);
        }

        // Resolve the function with proper gating context
        let prevGatedContext = this.#inGatedContext;
        if (funcGated) {
          this.#inGatedContext = true;
        }
        this.#resolveNamedFunc(rf.func);
        this.#inGatedContext = prevGatedContext;

        i = i + 1;
      }
    }

    // Check for duplicate flags
    if (td.tag == TypeDefTag.Flags) {
      let flags = td.flags as Array<FlagDef>;
      this.#checkDuplicateFlagNames(flags);
    }
  }

  #validateConstructorReturn(f: NamedFunc, resourceName: String): void {
    let func = f.func;
    if (func.result == null) {
      // No return type - that's fine
      return;
    }
    let result = func.result as Type;
    // Constructor return must be a result type
    if (result.tag != TypeTag.Result) {
      throw new ResolveError(
        "if a constructor return type is declared it must be a `result`",
        result.span
      );
    }
    // The ok type must be the resource being constructed (wildcard _ is not allowed)
    if (result.okType == null) {
      // Wildcard _ is not allowed
      throw new ResolveError(
        "the `ok` type must be the resource being constructed",
        result.span
      );
    }
    let okType = result.okType as Type;
    // ok type must be a Name pointing to this resource
    if (okType.tag != TypeTag.Name) {
      throw new ResolveError(
        "the `ok` type must be the resource being constructed",
        result.span
      );
    }
    let okName = (okType.name as Id).name;
    if (okName != resourceName) {
      throw new ResolveError(
        "the `ok` type must be the resource being constructed",
        okType.span
      );
    }
  }

  #checkDuplicateResourceFuncs(funcs: Array<ResourceFunc>): void {
    var constructorCount = 0;
    var constructorSpan: Span | null = null;
    var methodNames = new Array<SymbolEntry>();

    var i = 0;
    while (i < funcs.length) {
      let rf = funcs[i];
      if (rf.tag == ResourceFuncTag.Constructor) {
        constructorCount = constructorCount + 1;
        if (constructorCount == 1) {
          constructorSpan = rf.func.name.span;
        } else {
          throw new ResolveError("duplicate constructors", rf.func.name.span);
        }
      } else {
        // Method or static - check for duplicate names
        let name = rf.func.name.name;
        let existing = findSymbolInList(methodNames, name);
        if (existing != null) {
          throw new ResolveError("duplicate function name `" + name + "`", rf.func.name.span);
        }
        methodNames.push(new SymbolEntry(name, SymbolKind.Func, rf.func.name.span));
      }
      i = i + 1;
    }
  }

  #checkDuplicateCaseNames(cases: Array<EnumCaseDef>): void {
    var i = 0;
    while (i < cases.length) {
      var j = i + 1;
      while (j < cases.length) {
        if (cases[i].name.name == cases[j].name.name) {
          throw new ResolveError(
            "duplicate enum case `" + cases[j].name.name + "`",
            cases[j].name.span
          );
        }
        j = j + 1;
      }
      i = i + 1;
    }
  }

  #checkDuplicateVariantCases(cases: Array<Case>): void {
    var i = 0;
    while (i < cases.length) {
      var j = i + 1;
      while (j < cases.length) {
        if (cases[i].name.name == cases[j].name.name) {
          throw new ResolveError(
            "duplicate variant case `" + cases[j].name.name + "`",
            cases[j].name.span
          );
        }
        j = j + 1;
      }
      i = i + 1;
    }
  }

  #checkDuplicateFieldNames(fields: Array<Field>, typeSpan: Span): void {
    var i = 0;
    while (i < fields.length) {
      var j = i + 1;
      while (j < fields.length) {
        if (fields[i].name.name == fields[j].name.name) {
          throw new ResolveError(
            "duplicate field `" + fields[j].name.name + "`",
            fields[j].name.span
          );
        }
        j = j + 1;
      }
      i = i + 1;
    }
  }

  #checkDuplicateFlagNames(flags: Array<FlagDef>): void {
    var i = 0;
    while (i < flags.length) {
      var j = i + 1;
      while (j < flags.length) {
        if (flags[i].name.name == flags[j].name.name) {
          throw new ResolveError(
            "duplicate flag `" + flags[j].name.name + "`",
            flags[j].name.span
          );
        }
        j = j + 1;
      }
      i = i + 1;
    }
  }

  // --------------------------------------------------------------------------
  // Type Resolution
  // --------------------------------------------------------------------------

  #resolveType(t: Type, inReturnPosition: boolean): void {
    // Check for borrow<T> in return position
    if (t.tag == TypeTag.Borrow && inReturnPosition) {
      throw new ResolveError(
        "function returns a type which contains a `borrow<T>` which is not supported",
        t.span
      );
    }

    // Handle types (borrow<T> and own<T>) must reference a resource
    if (t.tag == TypeTag.Borrow || t.tag == TypeTag.Own) {
      let inner = t.inner as Type;
      // Inner type should always be a Name (enforced by parser)
      if (inner.tag == TypeTag.Name) {
        let rawName = (inner.name as Id).name;
        let name = stripExplicitPrefix(rawName);
        let sym = this.#findSymbol(name);
        if (sym == null) {
          throw new ResolveError("type `" + rawName + "` does not exist", inner.span);
        }
        // Check if the type is a resource
        let s = sym as SymbolEntry;
        if (s.kind == SymbolKind.Resource) {
          // Good - it's a resource
          return;
        }
        if (s.kind == SymbolKind.Type) {
          // Check if there's a TypeDef that's a resource, or if it was imported
          let td = this.#findTypeDef(name);
          if (td != null) {
            if (!this.#isResourceType(td as TypeDef)) {
              throw new ResolveError("type `" + rawName + "` used in a handle must be a resource", inner.span);
            }
            // TypeDef is a resource (or alias to one)
            return;
          }
          // No type definition found - the symbol was imported from another interface
          // via `use`. In that case, we trust the import (cross-interface resource 
          // validation would require tracking interface relationships)
          return;
        }
        // Symbol is not a Type or Resource (e.g., it's an Interface, World, or Func)
        throw new ResolveError("type `" + rawName + "` does not exist", inner.span);
      }
      return;
    }

    // Check for named type references
    if (t.tag == TypeTag.Name) {
      let rawName = (t.name as Id).name;
      // Strip explicit identifier prefix (%) if present
      let name = stripExplicitPrefix(rawName);
      // Check for cycle
      if (this.#isResolving(name)) {
        throw new ResolveError(
          "type `" + rawName + "` depends on itself",
          t.span
        );
      }
      // Check if type exists
      let sym = this.#findSymbol(name);
      if (sym == null) {
        throw new ResolveError("type `" + rawName + "` does not exist", t.span);
      }

      // Check feature gate (bad-gate1): can't reference gated type from non-gated context
      let s = sym as SymbolEntry;
      this.#checkGatedReference(s, t.span, "type");

      // Check that the symbol is a type, not a function (invalid-type-reference2)
      if (s.kind == SymbolKind.Func) {
        throw new ResolveError(
          "cannot use function `" + rawName + "` as a type",
          t.span
        );
      }

      // Follow type aliases to detect transitive cycles
      let td = this.#findTypeDef(name);
      if (td != null) {
        let typeDef = td as TypeDef;
        if (typeDef.tag == TypeDefTag.Alias) {
          // Add this type to the resolving stack and resolve its alias
          this.#resolving.push(name);
          this.#resolveType(typeDef.aliasType as Type, inReturnPosition);
          this.#resolving.pop();
        } else if (typeDef.tag == TypeDefTag.Record) {
          // Check record fields for cycles and borrow usage
          this.#resolving.push(name);
          let fields = typeDef.fields as Array<Field>;
          var i = 0;
          while (i < fields.length) {
            // Propagate inReturnPosition to catch borrow<T> in record fields
            this.#resolveType(fields[i].type, inReturnPosition);
            i = i + 1;
          }
          this.#resolving.pop();
        }
      }
    }

    // Check map key types
    if (t.tag == TypeTag.Map) {
      let keyType = t.keyType as Type;
      if (!isValidMapKeyType(keyType)) {
        throw new ResolveError(
          "invalid map key type: map keys must be bool, u8, u16, u32, u64, s8, s16, s32, s64, char, or string",
          t.span
        );
      }
      this.#resolveType(keyType, false);
      this.#resolveType(t.valueType as Type, false);
    }

    // Recurse into composite types
    if (t.tag == TypeTag.List || t.tag == TypeTag.Option ||
        t.tag == TypeTag.Future || t.tag == TypeTag.Stream) {
      if (t.inner != null) {
        this.#resolveType(t.inner as Type, inReturnPosition);
      }
    }

    if (t.tag == TypeTag.Result) {
      if (t.okType != null) {
        this.#resolveType(t.okType as Type, inReturnPosition);
      }
      if (t.errType != null) {
        this.#resolveType(t.errType as Type, inReturnPosition);
      }
    }

    if (t.tag == TypeTag.Tuple) {
      let types = t.types as Array<Type>;
      var i = 0;
      while (i < types.length) {
        this.#resolveType(types[i], inReturnPosition);
        i = i + 1;
      }
    }
  }

  #isResolving(name: String): boolean {
    var i = 0;
    while (i < this.#resolving.length) {
      if (this.#resolving[i] == name) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }

  /** Find a type definition by name in any scope. */
  #findTypeDef(name: String): TypeDef | null {
    var i = this.#scopes.length - 1;
    while (i >= 0) {
      let td = this.#scopes[i].findType(name);
      if (td != null) {
        return td;
      }
      i = i - 1;
    }
    return null;
  }

  /** Find a world definition by name in any scope. */
  #findWorldDef(name: String): WorldDef | null {
    var i = this.#scopes.length - 1;
    while (i >= 0) {
      let wd = this.#scopes[i].findWorld(name);
      if (wd != null) {
        return wd;
      }
      i = i - 1;
    }
    return null;
  }

  /** Check if a type definition is or refers to a resource. */
  #isResourceType(td: TypeDef): boolean {
    // Direct resource
    if (td.tag == TypeDefTag.Resource) {
      return true;
    }
    // Not an alias - not a resource
    if (td.tag != TypeDefTag.Alias) {
      return false;
    }
    // Check what the alias points to
    let aliasType = td.aliasType as Type;
    // If it's own<T> or borrow<T>, the inner type must be a resource
    if (aliasType.tag == TypeTag.Own || aliasType.tag == TypeTag.Borrow) {
      // Already validated by handle type checking
      return false;  // But the alias itself is not a resource
    }
    // If it aliases another name, check if that's a resource
    if (aliasType.tag == TypeTag.Name) {
      let name = (aliasType.name as Id).name;
      let sym = this.#findSymbol(name);
      if (sym != null) {
        let s = sym as SymbolEntry;
        if (s.kind == SymbolKind.Resource) {
          return true;
        }
        // If it's a Type, check if there's a local TypeDef or if it was imported
        if (s.kind == SymbolKind.Type) {
          let innerTd = this.#findTypeDef(name);
          if (innerTd != null) {
            return this.#isResourceType(innerTd as TypeDef);
          }
          // No TypeDef found - imported from another interface, trust it
          return true;
        }
      }
    }
    return false;
  }

  // --------------------------------------------------------------------------
  // Function Resolution
  // --------------------------------------------------------------------------

  #resolveNamedFunc(f: NamedFunc): void {
    this.#resolveFunc(f.func);
  }

  #resolveFunc(f: Func): void {
    // Check for duplicate parameter names
    this.#checkDuplicateParamNames(f.params);

    // Resolve parameter types
    var i = 0;
    while (i < f.params.length) {
      this.#resolveType(f.params[i].type, false);
      i = i + 1;
    }

    // Resolve return type
    if (f.result != null) {
      this.#resolveType(f.result as Type, true);
    }
  }

  #checkDuplicateParamNames(params: Array<Param>): void {
    var i = 0;
    while (i < params.length) {
      var j = i + 1;
      while (j < params.length) {
        if (params[i].name.name == params[j].name.name) {
          throw new ResolveError(
            "duplicate parameter `" + params[j].name.name + "`",
            params[j].name.span
          );
        }
        j = j + 1;
      }
      i = i + 1;
    }
  }

  // --------------------------------------------------------------------------
  // Use Statement Resolution
  // --------------------------------------------------------------------------

  /** Check if an interface is currently being resolved (for cycle detection). */
  #isResolvingInterface(name: String): boolean {
    var i = 0;
    while (i < this.#resolvingInterfaces.length) {
      if (this.#resolvingInterfaces[i] == name) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }

  #resolveUse(use: Use): void {
    // Validate the path references an existing interface
    this.#resolveUsePath(use.from, false);

    // Check that we're not using a world (only interfaces can be used)
    if (use.from.tag == UsePathTag.Id) {
      let id = use.from.id as Id;
      let sym = this.#findSymbol(id.name);
      if (sym != null) {
        let s = sym as SymbolEntry;
        if (s.kind == SymbolKind.World) {
          throw new ResolveError(
            "name `" + id.name + "` is defined as a world, not an interface",
            id.span
          );
        }
      }
      
      // Check for use cycle - if we're currently resolving this interface, it's a cycle
      if (this.#isResolvingInterface(id.name)) {
        throw new ResolveError(
          "interface or world `" + id.name + "` depends on itself",
          id.span
        );
      }
      
      // Recursively resolve the target interface to detect transitive cycles
      let iface = this.#findInterface(id.name);
      if (iface != null) {
        let ifaceDef = iface as InterfaceDef;
        // Only resolve if not already resolved (to avoid infinite recursion 
        // in valid cases where an interface is used multiple times)
        if (!this.#isResolvingInterface(ifaceDef.name.name)) {
          this.#resolveInterface(ifaceDef);
        }
      }
    }

    // Validate that imported names exist in the target interface
    this.#validateUseNames(use);

    // Add imported names to current scope
    var i = 0;
    while (i < use.names.length) {
      let useName = use.names[i];
      let name = if (useName.asName != null) (useName.asName as Id).name else useName.name.name;
      this.#define(name, SymbolKind.Type, useName.name.span);
      i = i + 1;
    }
  }

  /** Validate that names in a use statement exist in the target interface. */
  #validateUseNames(use: Use): void {
    if (use.from.tag == UsePathTag.Id) {
      // Local interface reference
      let id = use.from.id as Id;
      let iface = this.#findInterface(id.name);
      if (iface == null) {
        // Interface not found - already reported by #resolveUsePath
        return;
      }
      let ifaceDef = iface as InterfaceDef;
      this.#validateUseNamesInInterface(use, ifaceDef);
    } else if (use.from.tag == UsePathTag.Package) {
      // Cross-package reference
      let pkgId = use.from.packageId as PackageName;
      let itemName = use.from.name as Id;
      let registry = this.#registry as PackageRegistry;
      let iface = registry.getInterfaceByPkg(pkgId, itemName.name);
      if (iface == null) {
        // Interface not found - already reported by #resolveUsePath
        return;
      }
      this.#validateUseNamesInInterface(use, iface as InterfaceDef);
    }
  }

  /** Helper to validate use names against an interface definition. */
  #validateUseNamesInInterface(use: Use, ifaceDef: InterfaceDef): void {
    // Check each imported name
    var i = 0;
    while (i < use.names.length) {
      let useName = use.names[i];
      let lookupName = useName.name.name;
      let found = this.#findItemInInterface(ifaceDef, lookupName);
      if (found == null) {
        throw new ResolveError(
          "name `" + lookupName + "` is not defined",
          useName.name.span
        );
      }
      // Check it's a type, not a function
      let foundEntry = found as SymbolEntry;
      if (foundEntry.kind == SymbolKind.Func) {
        throw new ResolveError(
          "cannot import function `" + lookupName + "`",
          useName.name.span
        );
      }
      i = i + 1;
    }
  }

  /** Find an item in an interface by name, returning a SymbolEntry if found. */
  #findItemInInterface(iface: InterfaceDef, name: String): SymbolEntry | null {
    var i = 0;
    while (i < iface.items.length) {
      let item = iface.items[i];
      if (item.tag == InterfaceItemTag.TypeDef) {
        let td = item.typeDef as TypeDef;
        if (td.name.name == name) {
          let kind = if (td.tag == TypeDefTag.Resource) SymbolKind.Resource else SymbolKind.Type;
          return new SymbolEntry(name, kind, td.name.span);
        }
      } else if (item.tag == InterfaceItemTag.Func) {
        let f = item.func as NamedFunc;
        if (f.name.name == name) {
          return new SymbolEntry(name, SymbolKind.Func, f.name.span);
        }
      } else if (item.tag == InterfaceItemTag.Use) {
        // Check names brought in by use statements
        let u = item.use as Use;
        var j = 0;
        while (j < u.names.length) {
          let useName = u.names[j];
          let importedName = if (useName.asName != null) (useName.asName as Id).name else useName.name.name;
          if (importedName == name) {
            return new SymbolEntry(name, SymbolKind.Type, useName.name.span);  // Use imports are always types
          }
          j = j + 1;
        }
      }
      i = i + 1;
    }
    return null;
  }

  /** Find an interface definition by name in any scope. */
  #findInterface(name: String): InterfaceDef | null {
    var i = this.#scopes.length - 1;
    while (i >= 0) {
      let iface = this.#scopes[i].findInterface(name);
      if (iface != null) {
        return iface;
      }
      i = i - 1;
    }
    return null;
  }

  #resolveUsePath(path: UsePath, expectWorld: boolean): void {
    if (path.tag == UsePathTag.Id) {
      // Local reference
      let id = path.id as Id;
      
      if (expectWorld) {
        // For include statements, look for world definitions specifically
        // (to avoid shadowing by local record/type definitions)
        let worldDef = this.#findWorldDef(id.name);
        if (worldDef == null) {
          throw new ResolveError(
            "world `" + id.name + "` not found in package",
            id.span
          );
        }
      } else {
        // For use statements, check symbol table for interfaces
        let sym = this.#findSymbol(id.name);
        if (sym == null) {
          throw new ResolveError(
            "interface `" + id.name + "` not found in package",
            id.span
          );
        }
        // Verify it's an interface
        let s = sym as SymbolEntry;
        if (s.kind != SymbolKind.Interface) {
          throw new ResolveError(
            "`" + id.name + "` is not an interface",
            id.span
          );
        }
      }
    } else if (path.tag == UsePathTag.Package) {
      // Cross-package reference: namespace:name/interface
      let pkgId = path.packageId as PackageName;
      let itemName = path.name as Id;
      let registry = this.#registry as PackageRegistry;

      // Check if the package exists (using full PackageName with version)
      if (!registry.hasPackageByName(pkgId)) {
        let knownPkgs = registry.getKnownPackages();
        let knownStr = this.#formatKnownPackages(knownPkgs);
        var pkgStr = pkgId.namespace.name + ":" + pkgId.name.name;
        if (pkgId.version != null) {
          pkgStr = pkgStr + "@" + (pkgId.version as String);
        }
        throw new ResolveError(
          "package '" + pkgStr + "' not found. known packages:\n" + knownStr,
          pkgId.span
        );
      }

      // Check if the interface or world exists in that package based on expectWorld
      if (expectWorld) {
        let world = registry.getWorldByPkg(pkgId, itemName.name);
        if (world == null) {
          // Check if it's an interface (for better error message)
          let iface = registry.getInterfaceByPkg(pkgId, itemName.name);
          if (iface != null) {
            throw new ResolveError(
              "`" + itemName.name + "` is an interface, not a world",
              itemName.span
            );
          }
          var pkgStr2 = pkgId.namespace.name + ":" + pkgId.name.name;
          if (pkgId.version != null) {
            pkgStr2 = pkgStr2 + "@" + (pkgId.version as String);
          }
          throw new ResolveError(
            "world `" + itemName.name + "` not found in package `" + pkgStr2 + "`",
            itemName.span
          );
        }
      } else {
        let iface = registry.getInterfaceByPkg(pkgId, itemName.name);
        if (iface == null) {
          // Check if it's a world (for better error message)
          let world = registry.getWorldByPkg(pkgId, itemName.name);
          if (world != null) {
            throw new ResolveError(
              "`" + itemName.name + "` is a world, not an interface",
              itemName.span
            );
          }
          var pkgStr3 = pkgId.namespace.name + ":" + pkgId.name.name;
          if (pkgId.version != null) {
            pkgStr3 = pkgStr3 + "@" + (pkgId.version as String);
          }
          throw new ResolveError(
            "interface `" + itemName.name + "` not found in package `" + pkgStr3 + "`",
            itemName.span
          );
        }
      }
    }
  }

  /** Format known packages for error messages. */
  #formatKnownPackages(known: Array<String>): String {
    let sb = new StringBuilder(64);
    var i = 0;
    while (i < known.length) {
      sb.append("    ");
      sb.append(known[i]);
      if (i < known.length - 1) {
        sb.appendByte(10);  // newline
      }
      i = i + 1;
    }
    return sb.toString();
  }

  #resolveToplevelUse(use: ToplevelUse): void {
    // Top-level use brings an interface into scope.
    // The name is already defined in the first pass, so we just validate the path here.
    this.#resolveUsePath(use.item, false);
  }

  /** Check if a name is a kebab-case name (contains hyphens). */
  #isKebabName(name: String): boolean {
    var i = 0;
    while (i < name.length) {
      if (name.getByteAt(i) == 45) {  // 45 is '-'
        return true;
      }
      i = i + 1;
    }
    return false;
  }

  #resolveInclude(include: Include): void {
    // Validate the path (includes reference worlds)
    this.#resolveUsePath(include.from, true);

    // Validate include renames (only for local world references)
    if (include.from.tag == UsePathTag.Id && include.names.length > 0) {
      let worldId = include.from.id as Id;
      let worldDef = this.#findWorldDef(worldId.name);
      if (worldDef != null) {
        let w = worldDef as WorldDef;
        this.#validateIncludeNames(include, w);
      }
    }

    // Check for include cycles and feature gates
    if (include.from.tag == UsePathTag.Id) {
      let id = include.from.id as Id;
      let sym = this.#findSymbol(id.name);
      if (sym != null) {
        let s = sym as SymbolEntry;
        // Check feature gate (bad-gate2): can't include gated world from non-gated context
        this.#checkGatedReference(s, id.span, "world");

        // Check for include cycle - if we're already resolving this world, it's a cycle
        if (this.#isIncludingWorld(id.name)) {
          throw new ResolveError(
            "interface or world `" + id.name + "` depends on itself",
            id.span
          );
        }

        // Recursively resolve the included world to detect transitive cycles
        let worldDef2 = this.#findWorldDef(id.name);
        if (worldDef2 != null) {
          this.#resolveWorldIncludes(worldDef2 as WorldDef);
        }
      }
    }
  }

  /** Validate include rename names - kebab-names (functions) and resources can be renamed, not IDs (interfaces). */
  #validateIncludeNames(include: Include, world: WorldDef): void {
    var i = 0;
    while (i < include.names.length) {
      let incName = include.names[i];
      let name = incName.name.name;

      // Check if this name exists as a function (kebab-name) or resource in the world
      let isRenameableItem = this.#isRenameableItemInWorld(world, name);

      if (!isRenameableItem) {
        // Name either doesn't exist or is an interface (ID), not a function/resource
        throw new ResolveError(
          "no import or export kebab-name `" + name + "`. Note that an ID does not support renaming",
          include.from.getName().span
        );
      }
      i = i + 1;
    }
  }

  /** Check if a name in the world is renameable (function or resource). */
  #isRenameableItemInWorld(world: WorldDef, name: String): boolean {
    var i = 0;
    while (i < world.items.length) {
      let item = world.items[i];
      if (item.tag == WorldItemTag.Import) {
        let imp = item.importItem as Import;
        // Functions are "kebab-names" - interfaces paths don't support renaming
        if (imp.kind.tag == ExternKindTag.Func) {
          let funcName = imp.kind.name as Id;
          if (funcName.name == name) {
            return true;
          }
        }
      } else if (item.tag == WorldItemTag.Export) {
        let exp = item.exportItem as Export;
        if (exp.kind.tag == ExternKindTag.Func) {
          let funcName = exp.kind.name as Id;
          if (funcName.name == name) {
            return true;
          }
        }
      } else if (item.tag == WorldItemTag.TypeDef) {
        // Resources defined in the world can be renamed
        let td = item.typeDef as TypeDef;
        if (td.tag == TypeDefTag.Resource && td.name.name == name) {
          return true;
        }
      }
      i = i + 1;
    }
    return false;
  }

  /** Resolve only the includes within a world (for cycle detection). */
  #resolveWorldIncludes(world: WorldDef): void {
    // Track this world for include cycle detection
    this.#includingWorlds.push(world.name.name);

    // Only process includes - we don't need to fully resolve the world again
    var i = 0;
    while (i < world.items.length) {
      let item = world.items[i];
      if (item.tag == WorldItemTag.Include) {
        let inc = item.include as Include;
        // Set gated context based on the include's docs
        let prevGatedContext = this.#inGatedContext;
        if (isGated(inc.docs)) {
          this.#inGatedContext = true;
        }
        this.#resolveInclude(inc);
        this.#inGatedContext = prevGatedContext;
      }
      i = i + 1;
    }

    this.#includingWorlds.pop();
  }

  /** Check if a world is currently being included (for cycle detection). */
  #isIncludingWorld(name: String): boolean {
    var i = 0;
    while (i < this.#includingWorlds.length) {
      if (this.#includingWorlds[i] == name) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
}
