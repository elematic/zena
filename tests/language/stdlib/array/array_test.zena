// Array stdlib tests using zena:test
import {suite, test, TestContext} from 'zena:test';
import {equal, throws} from 'zena:assert';
import {Array} from 'zena:array';

export let tests = suite('Array', (): void => {
  test('constructor creates array with zero length', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    equal(arr.length, 0);
  });

  test('push adds elements and updates length', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    arr.push(10);
    arr.push(20);
    equal(arr.length, 2);
    equal(arr[0], 10);
    equal(arr[1], 20);
  });

  test('pop removes and returns last element', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    arr.push(10);
    arr.push(20);
    
    let v1 = arr.pop();
    equal(v1, 20);
    equal(arr.length, 1);
    
    let v2 = arr.pop();
    equal(v2, 10);
    equal(arr.length, 0);
  });

  test('set updates element at index', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    arr.push(10);
    arr[0] = 99;
    equal(arr[0], 99);
  });

  test('grow increases capacity when needed', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    arr.push(1);
    arr.push(2);
    arr.push(3);
    arr.push(4);
    arr.push(5);
    
    equal(arr.length, 5);
    equal(arr[0], 1);
    equal(arr[4], 5);
  });

  test('out of bounds access throws', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    arr.push(1);
    throws((): void => {
      let x = arr[1]; // Should throw - index out of bounds
    });
  });

  test('out of bounds set throws', (ctx: TestContext): void => {
    let arr = new Array<i32>(4);
    arr.push(1);
    throws((): void => {
      arr[1] = 2; // Should throw - index out of bounds
    });
  });

  // TODO: map test disabled - codegen bug with nested closures (closure inside test callback)
  // The standalone map.zena test works, but when map's closure is inside another closure it fails.
  // test('map transforms elements', (ctx: TestContext): void => {
  //   let arr = new Array<i32>(4);
  //   arr.push(1);
  //   arr.push(2);
  //   arr.push(3);
  //   
  //   let mapped = arr.map<i32>((x: i32) => x * 2);
  //   
  //   equal(mapped.length, 3);
  //   equal(mapped[0], 2);
  //   equal(mapped[1], 4);
  //   equal(mapped[2], 6);
  // });
});
